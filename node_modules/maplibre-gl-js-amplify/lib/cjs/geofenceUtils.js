"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDistanceBetweenCoordinates = exports.isGeofenceDisplayed = exports.isExistingGeofenceId = exports.isValidGeofenceId = exports.doesGeofenceExist = exports.getCircleFeatureFromCoords = exports.getPolygonFeatureFromBounds = exports.getGeofenceFeatureFromPolygon = exports.getGeofenceFeatureArray = void 0;
const along_1 = __importDefault(require("@turf/along"));
const circle_1 = __importDefault(require("@turf/circle"));
const length_1 = __importDefault(require("@turf/length"));
const helpers_1 = require("@turf/helpers");
const utils_1 = require("./utils");
const GEOFENCE_ID_REGEX = /^[-._\p{L}\p{N}]+$/iu;
const getGeofenceFeatureArray = (data) => {
    const coordinates = (0, utils_1.isGeofenceArray)(data)
        ? data.map((geofence) => geofence.geometry.polygon)
        : data;
    return {
        type: "Feature",
        geometry: {
            type: "MultiPolygon",
            coordinates,
        },
        properties: {},
    };
};
exports.getGeofenceFeatureArray = getGeofenceFeatureArray;
const getGeofenceFeatureFromPolygon = (polygon) => {
    return {
        type: "Feature",
        geometry: {
            type: "Polygon",
            coordinates: polygon,
        },
        properties: {},
    };
};
exports.getGeofenceFeatureFromPolygon = getGeofenceFeatureFromPolygon;
// Measures distance between the coordinate bounds and takes two points 1/4 from each coordinate to create a polygon
const getPolygonFeatureFromBounds = (id, bounds) => {
    const swCoordinate = bounds.getSouthWest().toArray();
    const neCoordinate = bounds.getNorthEast().toArray();
    const center = bounds.getCenter().toArray();
    const line = (0, helpers_1.lineString)([swCoordinate, center, neCoordinate]);
    const distanceInMiles = (0, length_1.default)(line, { units: "miles" });
    // Gets coordinates 1/4 along the line from each coordinate
    const southWestCoordinate = (0, along_1.default)(line, distanceInMiles / 4, {
        units: "miles",
    }).geometry.coordinates;
    const northeastCoordinate = (0, along_1.default)(line, distanceInMiles * (3 / 4), {
        units: "miles",
    }).geometry.coordinates;
    // Creates a polygon from the coordinates found along the line between the bounding coordinates in counter clockwise order starting from northeast most coordinate
    const polygon = [
        [
            northeastCoordinate,
            [southWestCoordinate[0], northeastCoordinate[1]],
            southWestCoordinate,
            [northeastCoordinate[0], southWestCoordinate[1]],
            northeastCoordinate,
        ],
    ];
    return {
        id,
        type: "Feature",
        geometry: {
            type: "Polygon",
            coordinates: polygon,
        },
        properties: {},
    };
};
exports.getPolygonFeatureFromBounds = getPolygonFeatureFromBounds;
const getCircleFeatureFromCoords = (id, center, { bounds, radius }) => {
    if (!bounds && !radius) {
        throw new Error("Circle requires a bounds or a radius");
    }
    (0, utils_1.validateCoordinates)(center);
    const circleRadius = radius !== null && radius !== void 0 ? radius : getDistanceFromBounds(bounds) / 8;
    const circleFeature = (0, circle_1.default)(center, circleRadius, { units: "miles" });
    return {
        id,
        type: "Feature",
        properties: {
            isCircle: true,
            center,
            radius: circleRadius,
        },
        geometry: {
            type: "Polygon",
            coordinates: circleFeature.geometry.coordinates,
        },
    };
};
exports.getCircleFeatureFromCoords = getCircleFeatureFromCoords;
const getDistanceFromBounds = (bounds) => {
    const swCoordinate = bounds.getSouthWest().toArray();
    const neCoordinate = bounds.getNorthEast().toArray();
    const center = bounds.getCenter().toArray();
    const line = (0, helpers_1.lineString)([swCoordinate, center, neCoordinate]);
    return (0, length_1.default)(line, { units: "miles" });
};
const doesGeofenceExist = (id, loadedGeofences) => {
    return !!loadedGeofences[id];
};
exports.doesGeofenceExist = doesGeofenceExist;
const isValidGeofenceId = (id) => {
    return !!id.match(GEOFENCE_ID_REGEX);
};
exports.isValidGeofenceId = isValidGeofenceId;
const isExistingGeofenceId = (id, loadedGeofences) => {
    return (0, exports.doesGeofenceExist)(id, loadedGeofences);
};
exports.isExistingGeofenceId = isExistingGeofenceId;
const isGeofenceDisplayed = (id, displayedGeofences) => {
    return !!displayedGeofences.find((geofence) => geofence.geofenceId === id);
};
exports.isGeofenceDisplayed = isGeofenceDisplayed;
const getDistanceBetweenCoordinates = (startCoord, endCoord) => {
    const line = (0, helpers_1.lineString)([startCoord, endCoord]);
    const distanceInMiles = (0, length_1.default)(line, { units: "miles" });
    return distanceInMiles;
};
exports.getDistanceBetweenCoordinates = getDistanceBetweenCoordinates;
