import {
  Amplify,
  Geo,
  Hub,
  Signer,
  degreesToRadians,
  feature,
  getAmplifyUserAgent,
  getCoord,
  getGeom,
  jitteredExponentialRetry,
  lengthToRadians,
  lineString,
  point,
  polygon,
  radiansToDegrees,
  radiansToLength,
  require_events
} from "./chunk-YLPAGW6Z.js";
import {
  require_maplibre_gl
} from "./chunk-WNQ3LWUW.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-IKJM6GHQ.js";

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/fuzzy/lib/fuzzy.js
var require_fuzzy = __commonJS({
  "node_modules/fuzzy/lib/fuzzy.js"(exports, module) {
    (function() {
      var root = this;
      var fuzzy = {};
      if (typeof exports !== "undefined") {
        module.exports = fuzzy;
      } else {
        root.fuzzy = fuzzy;
      }
      fuzzy.simpleFilter = function(pattern, array) {
        return array.filter(function(str) {
          return fuzzy.test(pattern, str);
        });
      };
      fuzzy.test = function(pattern, str) {
        return fuzzy.match(pattern, str) !== null;
      };
      fuzzy.match = function(pattern, str, opts) {
        opts = opts || {};
        var patternIdx = 0, result = [], len = str.length, totalScore = 0, currScore = 0, pre = opts.pre || "", post = opts.post || "", compareString = opts.caseSensitive && str || str.toLowerCase(), ch;
        pattern = opts.caseSensitive && pattern || pattern.toLowerCase();
        for (var idx = 0; idx < len; idx++) {
          ch = str[idx];
          if (compareString[idx] === pattern[patternIdx]) {
            ch = pre + ch + post;
            patternIdx += 1;
            currScore += 1 + currScore;
          } else {
            currScore = 0;
          }
          totalScore += currScore;
          result[result.length] = ch;
        }
        if (patternIdx === pattern.length) {
          totalScore = compareString === pattern ? Infinity : totalScore;
          return { rendered: result.join(""), score: totalScore };
        }
        return null;
      };
      fuzzy.filter = function(pattern, arr, opts) {
        if (!arr || arr.length === 0) {
          return [];
        }
        if (typeof pattern !== "string") {
          return arr;
        }
        opts = opts || {};
        return arr.reduce(function(prev, element, idx, arr2) {
          var str = element;
          if (opts.extract) {
            str = opts.extract(element);
          }
          var rendered = fuzzy.match(pattern, str, opts);
          if (rendered != null) {
            prev[prev.length] = {
              string: rendered.rendered,
              score: rendered.score,
              index: idx,
              original: element
            };
          }
          return prev;
        }, []).sort(function(a, b) {
          var compare = b.score - a.score;
          if (compare)
            return compare;
          return a.index - b.index;
        });
      };
    })();
  }
});

// node_modules/suggestions-list/src/list.js
var require_list = __commonJS({
  "node_modules/suggestions-list/src/list.js"(exports, module) {
    "use strict";
    var List = function(component) {
      this.component = component;
      this.items = [];
      this.active = component.options.noInitialSelection ? -1 : 0;
      this.wrapper = document.createElement("div");
      this.wrapper.className = "suggestions-wrapper";
      this.element = document.createElement("ul");
      this.element.className = "suggestions";
      this.wrapper.appendChild(this.element);
      this.selectingListItem = false;
      component.el.parentNode.insertBefore(this.wrapper, component.el.nextSibling);
      return this;
    };
    List.prototype.show = function() {
      this.element.style.display = "block";
    };
    List.prototype.hide = function() {
      this.element.style.display = "none";
    };
    List.prototype.add = function(item) {
      this.items.push(item);
    };
    List.prototype.clear = function() {
      this.items = [];
      this.active = this.component.options.noInitialSelection ? -1 : 0;
    };
    List.prototype.isEmpty = function() {
      return !this.items.length;
    };
    List.prototype.isVisible = function() {
      return this.element.style.display === "block";
    };
    List.prototype.draw = function() {
      this.element.innerHTML = "";
      if (this.items.length === 0) {
        this.hide();
        return;
      }
      for (var i = 0; i < this.items.length; i++) {
        this.drawItem(this.items[i], this.active === i);
      }
      this.show();
    };
    List.prototype.drawItem = function(item, active) {
      var li = document.createElement("li"), a = document.createElement("a");
      if (active)
        li.className += " active";
      a.innerHTML = item.string;
      li.appendChild(a);
      this.element.appendChild(li);
      li.addEventListener("mousedown", function() {
        this.selectingListItem = true;
      }.bind(this));
      li.addEventListener("mouseup", function() {
        this.handleMouseUp.call(this, item);
      }.bind(this));
    };
    List.prototype.handleMouseUp = function(item) {
      this.selectingListItem = false;
      this.component.value(item.original);
      this.clear();
      this.draw();
    };
    List.prototype.move = function(index) {
      this.active = index;
      this.draw();
    };
    List.prototype.previous = function() {
      this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
    };
    List.prototype.next = function() {
      this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
    };
    List.prototype.drawError = function(msg) {
      var li = document.createElement("li");
      li.innerHTML = msg;
      this.element.appendChild(li);
      this.show();
    };
    module.exports = List;
  }
});

// node_modules/suggestions-list/src/suggestions.js
var require_suggestions = __commonJS({
  "node_modules/suggestions-list/src/suggestions.js"(exports, module) {
    "use strict";
    var extend = require_immutable();
    var fuzzy = require_fuzzy();
    var List = require_list();
    var Suggestions = function(el, data, options) {
      options = options || {};
      this.options = extend({
        minLength: 2,
        limit: 5,
        filter: true,
        hideOnBlur: true,
        noInitialSelection: true
      }, options);
      this.el = el;
      this.data = data || [];
      this.list = new List(this);
      this.query = "";
      this.selected = null;
      this.list.draw();
      this.el.addEventListener("keyup", function(e2) {
        this.handleKeyUp(e2.keyCode, e2);
      }.bind(this), false);
      this.el.addEventListener("keydown", function(e2) {
        this.handleKeyDown(e2);
      }.bind(this));
      this.el.addEventListener("focus", function() {
        this.handleFocus();
      }.bind(this));
      this.el.addEventListener("blur", function() {
        this.handleBlur();
      }.bind(this));
      this.el.addEventListener("paste", function(e2) {
        this.handlePaste(e2);
      }.bind(this));
      this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this);
      this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this);
      return this;
    };
    Suggestions.prototype.handleKeyUp = function(keyCode, e2) {
      if (keyCode === 40 || keyCode === 38 || keyCode === 27 || keyCode === 9)
        return;
      if (keyCode === 13) {
        if (this.list.items[this.list.active]) {
          this.list.handleMouseUp(this.list.items[this.list.active]);
          e2.stopPropagation();
        }
        return;
      }
      this.handleInputChange(this.el.value);
    };
    Suggestions.prototype.handleKeyDown = function(e2) {
      switch (e2.keyCode) {
        case 13:
          if (this.list.active >= 0) {
            this.list.selectingListItem = true;
          }
          break;
        case 9:
          if (!this.list.isEmpty()) {
            if (this.list.isVisible()) {
              e2.preventDefault();
            }
            this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null);
            this.list.hide();
          }
          break;
        case 27:
          if (!this.list.isEmpty())
            this.list.hide();
          break;
        case 38:
          this.list.previous();
          break;
        case 40:
          this.list.next();
          break;
      }
    };
    Suggestions.prototype.handleBlur = function() {
      if (!this.list.selectingListItem && this.options.hideOnBlur) {
        this.list.hide();
      }
    };
    Suggestions.prototype.handlePaste = function(e2) {
      if (e2.clipboardData) {
        this.handleInputChange(e2.clipboardData.getData("Text"));
      } else {
        var self2 = this;
        setTimeout(function() {
          self2.handleInputChange(e2.target.value);
        }, 100);
      }
    };
    Suggestions.prototype.handleInputChange = function(query) {
      this.query = this.normalize(query);
      this.list.clear();
      if (this.query.length < this.options.minLength) {
        this.list.draw();
        return;
      }
      this.getCandidates(function(data) {
        for (var i = 0; i < data.length; i++) {
          this.list.add(data[i]);
          if (i === this.options.limit - 1)
            break;
        }
        this.list.draw();
      }.bind(this));
    };
    Suggestions.prototype.handleFocus = function() {
      if (!this.list.isEmpty())
        this.list.show();
      this.list.selectingListItem = false;
    };
    Suggestions.prototype.update = function(revisedData) {
      this.data = revisedData;
      this.handleKeyUp();
    };
    Suggestions.prototype.clear = function() {
      this.data = [];
      this.list.clear();
    };
    Suggestions.prototype.normalize = function(value) {
      value = value.toLowerCase();
      return value;
    };
    Suggestions.prototype.match = function(candidate, query) {
      return candidate.indexOf(query) > -1;
    };
    Suggestions.prototype.value = function(value) {
      this.selected = value;
      this.el.value = this.getItemValue(value || { place_name: this.query });
      if (document.createEvent) {
        var e2 = document.createEvent("HTMLEvents");
        e2.initEvent("change", true, false);
        this.el.dispatchEvent(e2);
      } else {
        this.el.fireEvent("onchange");
      }
    };
    Suggestions.prototype.getCandidates = function(callback) {
      var options = {
        pre: "<strong>",
        post: "</strong>",
        extract: function(d) {
          return this.getItemValue(d);
        }.bind(this)
      };
      var results;
      if (this.options.filter) {
        results = fuzzy.filter(this.query, this.data, options);
        results = results.map(function(item) {
          return {
            original: item.original,
            string: this.render(item.original, item.string)
          };
        }.bind(this));
      } else {
        results = this.data.map(function(d) {
          var renderedString = this.render(d);
          return {
            original: d,
            string: renderedString
          };
        }.bind(this));
      }
      callback(results);
    };
    Suggestions.prototype.getItemValue = function(item) {
      return item;
    };
    Suggestions.prototype.render = function(item, sourceFormatting) {
      if (sourceFormatting) {
        return sourceFormatting;
      }
      var boldString = item.original ? this.getItemValue(item.original) : this.getItemValue(item);
      var indexString = this.normalize(boldString);
      var indexOfQuery = indexString.lastIndexOf(this.query);
      while (indexOfQuery > -1) {
        var endIndexOfQuery = indexOfQuery + this.query.length;
        boldString = boldString.slice(0, indexOfQuery) + "<strong>" + boldString.slice(indexOfQuery, endIndexOfQuery) + "</strong>" + boldString.slice(endIndexOfQuery);
        indexOfQuery = indexString.slice(0, indexOfQuery).lastIndexOf(this.query);
      }
      return boldString;
    };
    Suggestions.prototype.renderError = function(msg) {
      this.list.drawError(msg);
    };
    module.exports = Suggestions;
  }
});

// node_modules/suggestions-list/index.js
var require_suggestions_list = __commonJS({
  "node_modules/suggestions-list/index.js"(exports, module) {
    "use strict";
    var Suggestions = require_suggestions();
    module.exports = Suggestions;
    if (typeof window !== "undefined") {
      window.Suggestions = Suggestions;
    }
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject2(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject2(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject2(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce2;
  }
});

// node_modules/@maplibre/maplibre-gl-geocoder/lib/exceptions.js
var require_exceptions = __commonJS({
  "node_modules/@maplibre/maplibre-gl-geocoder/lib/exceptions.js"(exports, module) {
    module.exports = {
      "fr": {
        "name": "France",
        "bbox": [[-4.59235, 41.380007], [9.560016, 51.148506]]
      },
      "us": {
        "name": "United States",
        "bbox": [[-171.791111, 18.91619], [-66.96466, 71.357764]]
      },
      "ru": {
        "name": "Russia",
        "bbox": [[19.66064, 41.151416], [190.10042, 81.2504]]
      },
      "ca": {
        "name": "Canada",
        "bbox": [[-140.99778, 41.675105], [-52.648099, 83.23324]]
      }
    };
  }
});

// node_modules/@maplibre/maplibre-gl-geocoder/lib/localization.js
var require_localization = __commonJS({
  "node_modules/@maplibre/maplibre-gl-geocoder/lib/localization.js"(exports, module) {
    "use strict";
    var placeholder = {
      "de": "Suche",
      "it": "Ricerca",
      "en": "Search",
      "nl": "Zoeken",
      "fr": "Chercher",
      "ca": "Cerca",
      "he": "\u05DC\u05D7\u05E4\u05E9",
      "ja": "\u30B5\u30FC\u30C1",
      "lv": "Mekl\u0113t",
      "pt": "Procurar",
      "sr": "\u041F\u0440\u0435\u0442\u0440\u0430\u0433\u0430",
      "zh": "\u641C\u7D22",
      "cs": "Vyhled\xE1v\xE1n\xED",
      "hu": "Keres\xE9s",
      "ka": "\u10EB\u10D8\u10D4\u10D1\u10D0",
      "nb": "S\xF8ke",
      "sk": "Vyh\u013Ead\xE1vanie",
      "th": "\u0E04\u0E49\u0E19\u0E2B\u0E32",
      "fi": "Hae",
      "is": "Leita",
      "ko": "\uC218\uC0C9",
      "pl": "Szukaj",
      "sl": "Iskanje",
      "fa": "\u062C\u0633\u062A\u062C\u0648",
      "ru": "\u041F\u043E\u0438\u0441\u043A"
    };
    module.exports = { placeholder };
  }
});

// node_modules/subtag/subtag.js
var require_subtag = __commonJS({
  "node_modules/subtag/subtag.js"(exports, module) {
    !function(root, name, make) {
      if (typeof module != "undefined" && module.exports)
        module.exports = make();
      else
        root[name] = make();
    }(exports, "subtag", function() {
      var empty = "";
      var pattern = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
      function match(tag) {
        return tag.match(pattern) || [];
      }
      function split(tag) {
        return match(tag).filter(function(v, i) {
          return v && i;
        });
      }
      function api(tag) {
        tag = match(tag);
        return {
          language: tag[1] || empty,
          extlang: tag[2] || empty,
          script: tag[3] || empty,
          region: tag[4] || empty
        };
      }
      function expose(target, key, value) {
        Object.defineProperty(target, key, {
          value,
          enumerable: true
        });
      }
      function part(position, pattern2, type) {
        function method(tag) {
          return match(tag)[position] || empty;
        }
        expose(method, "pattern", pattern2);
        expose(api, type, method);
      }
      part(1, /^[a-zA-Z]{2,3}$/, "language");
      part(2, /^[a-zA-Z]{3}$/, "extlang");
      part(3, /^[a-zA-Z]{4}$/, "script");
      part(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region");
      expose(api, "split", split);
      return api;
    });
  }
});

// node_modules/@maplibre/maplibre-gl-geocoder/lib/index.js
var require_lib = __commonJS({
  "node_modules/@maplibre/maplibre-gl-geocoder/lib/index.js"(exports, module) {
    "use strict";
    var Typeahead = require_suggestions_list();
    var debounce2 = require_lodash();
    var extend = require_immutable();
    var EventEmitter = require_events().EventEmitter;
    var exceptions = require_exceptions();
    var localization = require_localization();
    var subtag = require_subtag();
    function MaplibreGeocoder2(geocoderApi, options) {
      this._eventEmitter = new EventEmitter();
      this.options = extend({}, this.options, options);
      this.inputString = "";
      this.fresh = true;
      this.lastSelected = null;
      this.geocoderApi = geocoderApi;
    }
    MaplibreGeocoder2.prototype = {
      options: {
        zoom: 16,
        flyTo: true,
        trackProximity: true,
        showResultsWhileTyping: false,
        minLength: 2,
        reverseGeocode: false,
        limit: 5,
        enableEventLogging: true,
        marker: true,
        popup: false,
        maplibregl: null,
        collapsed: false,
        clearAndBlurOnEsc: false,
        clearOnBlur: false,
        getItemValue: function(item) {
          return item.text !== void 0 ? item.text : item.place_name;
        },
        render: function(item) {
          if (!item.geometry) {
            var suggestionString = item.text;
            var indexOfMatch = suggestionString.toLowerCase().indexOf(this.query.toLowerCase());
            var lengthOfMatch = this.query.length;
            var beforeMatch = suggestionString.substring(0, indexOfMatch);
            var match = suggestionString.substring(
              indexOfMatch,
              indexOfMatch + lengthOfMatch
            );
            var afterMatch = suggestionString.substring(
              indexOfMatch + lengthOfMatch
            );
            return '<div class="mapboxgl-ctrl-geocoder--suggestion maplibregl-ctrl-geocoder--suggestion"><svg class="mapboxgl-ctrl-geocoder--suggestion-icon maplibre-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="mapboxgl-ctrl-geocoder--suggestion-info maplibregl-ctrl-geocoder--suggestion-info"><div class="mapboxgl-ctrl-geocoder--suggestion-title maplibregl-ctrl-geocoder--suggestion-title">' + beforeMatch + '<span class="mapboxgl-ctrl-geocoder--suggestion-match maplibregl-ctrl-geocoder--suggestion-match">' + match + "</span>" + afterMatch + "</div></div></div>";
          } else {
            var placeName = item.place_name.split(",");
            return '<div class="mapboxgl-ctrl-geocoder--result maplibregl-ctrl-geocoder--result"><svg class="mapboxgl-ctrl-geocoder--result-icon maplibre-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="mapboxgl-ctrl-geocoder--result-title maplibregl-ctrl-geocoder--result-title">' + placeName[0] + '</div><div class="mapboxgl-ctrl-geocoder--result-address maplibregl-ctrl-geocoder--result-address">' + placeName.splice(1, placeName.length).join(",") + "</div></div></div>";
          }
        },
        popupRender: function(item) {
          var placeName = item.place_name.split(",");
          return '<div class="mapboxgl-ctrl-geocoder--suggestion maplibre-ctrl-geocoder--suggestion popup-suggestion"><div class="mapboxgl-ctrl-geocoder--suggestion-title maplibre-ctrl-geocoder--suggestion-title popup-suggestion-title">' + placeName[0] + '</div><div class="mapboxgl-ctrl-geocoder--suggestion-address maplibre-ctrl-geocoder--suggestion-address popup-suggestion-address">' + placeName.splice(1, placeName.length).join(",") + "</div></div>";
        },
        showResultMarkers: true,
        debounceSearch: 200
      },
      addTo: function(container) {
        function addToExistingContainer(geocoder, container2) {
          if (!document.body.contains(container2)) {
            throw new Error(
              "Element provided to #addTo() exists, but is not in the DOM"
            );
          }
          var el = geocoder.onAdd();
          container2.appendChild(el);
        }
        if (container._controlContainer) {
          container.addControl(this);
        } else if (container instanceof HTMLElement) {
          addToExistingContainer(this, container);
        } else if (typeof container == "string") {
          var parent = document.querySelectorAll(container);
          if (parent.length === 0) {
            throw new Error("Element ", container, "not found.");
          }
          if (parent.length > 1) {
            throw new Error("Geocoder can only be added to a single html element");
          }
          addToExistingContainer(this, parent[0]);
        } else {
          throw new Error(
            "Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element"
          );
        }
      },
      onAdd: function(map) {
        if (map && typeof map != "string") {
          this._map = map;
        }
        this.setLanguage();
        if (this.options.localGeocoderOnly && !this.options.localGeocoder) {
          throw new Error(
            "A localGeocoder function must be specified to use localGeocoderOnly mode"
          );
        }
        this._onChange = this._onChange.bind(this);
        this._onKeyDown = this._onKeyDown.bind(this);
        this._onPaste = this._onPaste.bind(this);
        this._onBlur = this._onBlur.bind(this);
        this._showButton = this._showButton.bind(this);
        this._hideButton = this._hideButton.bind(this);
        this._onQueryResult = this._onQueryResult.bind(this);
        this.clear = this.clear.bind(this);
        this._updateProximity = this._updateProximity.bind(this);
        this._collapse = this._collapse.bind(this);
        this._unCollapse = this._unCollapse.bind(this);
        this._clear = this._clear.bind(this);
        this._clearOnBlur = this._clearOnBlur.bind(this);
        var el = this.container = document.createElement("div");
        el.className = "mapboxgl-ctrl-geocoder mapboxgl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
        var searchIcon = this.createIcon(
          "search",
          '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>'
        );
        this._inputEl = document.createElement("input");
        this._inputEl.type = "text";
        this._inputEl.className = "mapboxgl-ctrl-geocoder--input maplibregl-ctrl-geocoder--input";
        this.setPlaceholder();
        if (this.options.collapsed) {
          this._collapse();
          this.container.addEventListener("mouseenter", this._unCollapse);
          this.container.addEventListener("mouseleave", this._collapse);
          this._inputEl.addEventListener("focus", this._unCollapse);
        }
        if (this.options.collapsed || this.options.clearOnBlur) {
          this._inputEl.addEventListener("blur", this._onBlur);
        }
        this._inputEl.addEventListener(
          "keydown",
          debounce2(this._onKeyDown, this.options.debounceSearch)
        );
        this._inputEl.addEventListener("paste", this._onPaste);
        this._inputEl.addEventListener("change", this._onChange);
        this.container.addEventListener("mouseenter", this._showButton);
        this.container.addEventListener("mouseleave", this._hideButton);
        var actions = document.createElement("div");
        actions.classList.add(
          "mapboxgl-ctrl-geocoder--pin-right",
          "maplibregl-ctrl-geocoder--pin-right"
        );
        this._clearEl = document.createElement("button");
        this._clearEl.setAttribute("aria-label", "Clear");
        this._clearEl.addEventListener("click", this.clear);
        this._clearEl.className = "mapboxgl-ctrl-geocoder--button maplibregl-ctrl-geocoder--button";
        var buttonIcon = this.createIcon(
          "close",
          '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>'
        );
        this._clearEl.appendChild(buttonIcon);
        this._loadingEl = this.createIcon(
          "loading",
          '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'
        );
        actions.appendChild(this._clearEl);
        actions.appendChild(this._loadingEl);
        el.appendChild(searchIcon);
        el.appendChild(this._inputEl);
        el.appendChild(actions);
        this._typeahead = new Typeahead(this._inputEl, [], {
          filter: false,
          minLength: this.options.minLength,
          limit: this.options.limit,
          noInitialSelection: true
        });
        this.setRenderFunction(this.options.render);
        this._typeahead.getItemValue = this.options.getItemValue;
        this.mapMarker = null;
        this.resultMarkers = [];
        this._handleMarker = this._handleMarker.bind(this);
        this._handleResultMarkers = this._handleResultMarkers.bind(this);
        if (this._map) {
          if (this.options.trackProximity) {
            this._updateProximity();
            this._map.on("moveend", this._updateProximity);
          }
          this._maplibregl = this.options.maplibregl;
          if (!this._maplibregl && this.options.marker) {
            console.error(
              "No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."
            );
            this.options.marker = false;
          }
        }
        return el;
      },
      createIcon: function(name, path) {
        var icon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        icon.setAttribute(
          "class",
          "mapboxgl-ctrl-geocoder--icon mapboxgl-ctrl-geocoder--icon-" + name + " maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + name
        );
        icon.setAttribute("viewBox", "0 0 18 18");
        icon.setAttribute("xml:space", "preserve");
        icon.setAttribute("width", 18);
        icon.setAttribute("height", 18);
        if (!("innerHTML" in icon)) {
          var SVGNodeContainer = document.createElement("div");
          SVGNodeContainer.innerHTML = "<svg>" + path.valueOf().toString() + "</svg>";
          var SVGNode = SVGNodeContainer.firstChild, SVGPath = SVGNode.firstChild;
          icon.appendChild(SVGPath);
        } else {
          icon.innerHTML = path;
        }
        return icon;
      },
      onRemove: function() {
        this.container.parentNode.removeChild(this.container);
        if (this.options.trackProximity && this._map) {
          this._map.off("moveend", this._updateProximity);
        }
        this._removeMarker();
        this._map = null;
        return this;
      },
      _onPaste: function(e2) {
        var value = (e2.clipboardData || window.clipboardData).getData("text");
        if (value.length >= this.options.minLength && this.options.showResultsWhileTyping) {
          this._geocode(value);
        }
      },
      _onKeyDown: function(e2) {
        var ESC_KEY_CODE = 27, TAB_KEY_CODE = 9;
        if (e2.keyCode === ESC_KEY_CODE && this.options.clearAndBlurOnEsc) {
          this._clear(e2);
          return this._inputEl.blur();
        }
        var target = e2.target && e2.target.shadowRoot ? e2.target.shadowRoot.activeElement : e2.target;
        var value = target ? target.value : "";
        if (!value) {
          this.fresh = true;
          if (e2.keyCode !== TAB_KEY_CODE)
            this.clear(e2);
          return this._clearEl.style.display = "none";
        }
        if (e2.metaKey || [TAB_KEY_CODE, ESC_KEY_CODE, 37, 39, 38, 40].indexOf(e2.keyCode) !== -1)
          return;
        if (e2.keyCode === 13) {
          if (!this.options.showResultsWhileTyping) {
            if (!this._typeahead.selected) {
              this._geocode(target.value);
            }
          } else {
            if (this._typeahead.selected == null && this.geocoderApi.getSuggestions) {
              this._geocode(target.value, true);
            } else if (this._typeahead.selected == null) {
              if (this.options.showResultMarkers) {
                this._fitBoundsForMarkers();
              }
            }
            return;
          }
        }
        if (target.value.length >= this.options.minLength && this.options.showResultsWhileTyping) {
          this._geocode(target.value);
        }
      },
      _showButton: function() {
        if (this._inputEl.value.length > 0)
          this._clearEl.style.display = "block";
      },
      _hideButton: function() {
        if (this._typeahead.selected)
          this._clearEl.style.display = "none";
      },
      _onBlur: function(e2) {
        if (this.options.clearOnBlur) {
          this._clearOnBlur(e2);
        }
        if (this.options.collapsed) {
          this._collapse();
        }
      },
      _onChange: function() {
        var selected = this._typeahead.selected;
        if (selected && !selected.geometry) {
          if (selected.placeId)
            this._geocode(selected.placeId, true, true);
          else
            this._geocode(selected.text, true);
        } else if (selected && JSON.stringify(selected) !== this.lastSelected) {
          this._clearEl.style.display = "none";
          if (this.options.flyTo) {
            var flyOptions;
            this._removeResultMarkers();
            if (selected.properties && exceptions[selected.properties.short_code]) {
              flyOptions = extend({}, this.options.flyTo);
              if (this._map) {
                this._map.fitBounds(
                  exceptions[selected.properties.short_code].bbox,
                  flyOptions
                );
              }
            } else if (selected.bbox) {
              var bbox = selected.bbox;
              flyOptions = extend({}, this.options.flyTo);
              if (this._map) {
                this._map.fitBounds(
                  [
                    [bbox[0], bbox[1]],
                    [bbox[2], bbox[3]]
                  ],
                  flyOptions
                );
              }
            } else {
              var defaultFlyOptions = {
                zoom: this.options.zoom
              };
              flyOptions = extend({}, defaultFlyOptions, this.options.flyTo);
              if (selected.center) {
                flyOptions.center = selected.center;
              } else if (selected.geometry && selected.geometry.type && selected.geometry.type === "Point" && selected.geometry.coordinates) {
                flyOptions.center = selected.geometry.coordinates;
              }
              if (this._map) {
                this._map.flyTo(flyOptions);
              }
            }
          }
          if (this.options.marker && this._maplibregl) {
            this._handleMarker(selected);
          }
          this._inputEl.focus();
          this._inputEl.scrollLeft = 0;
          this._inputEl.setSelectionRange(0, 0);
          this.lastSelected = JSON.stringify(selected);
          this._typeahead.selected = null;
          this._eventEmitter.emit("result", { result: selected });
        }
      },
      _getConfigForRequest: function() {
        var keys = [
          "bbox",
          "limit",
          "proximity",
          "countries",
          "types",
          "language",
          "reverseMode"
        ];
        var self2 = this;
        var config = keys.reduce(function(config2, key) {
          if (self2.options[key]) {
            ["countries", "types", "language"].indexOf(key) > -1 ? config2[key] = self2.options[key].split(/[\s,]+/) : config2[key] = self2.options[key];
            if (key === "proximity" && self2.options[key] && typeof self2.options[key].longitude === "number" && typeof self2.options[key].latitude === "number") {
              config2[key] = [
                self2.options[key].longitude,
                self2.options[key].latitude
              ];
            }
          }
          return config2;
        }, {});
        return config;
      },
      _geocode: function(searchInput, isSuggestion, isPlaceId) {
        this._loadingEl.style.display = "block";
        this._eventEmitter.emit("loading", { query: searchInput });
        this.inputString = searchInput;
        var geocoderError = null;
        var config = this._getConfigForRequest();
        var request;
        if (this.options.localGeocoderOnly) {
          request = Promise.resolve();
        } else if (this.options.reverseGeocode && /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/.test(searchInput)) {
          var coords = searchInput.split(/[\s(,)?]+/).map(function(c) {
            return parseFloat(c, 10);
          }).reverse();
          config.types ? [config.types[0]] : ["poi"];
          config = extend(config, { query: coords, limit: 1 });
          if ("proximity" in config) {
            delete config.proximity;
          }
          request = this.geocoderApi.reverseGeocode(config);
        } else {
          config = extend(config, { query: searchInput });
          if (!this.geocoderApi.getSuggestions) {
            request = this.geocoderApi.forwardGeocode(config);
          } else {
            if (isSuggestion) {
              if (this.geocoderApi.searchByPlaceId && isPlaceId) {
                request = this.geocoderApi.searchByPlaceId(config);
              } else {
                request = this.geocoderApi.forwardGeocode(config);
              }
            } else {
              request = this.geocoderApi.getSuggestions(config);
            }
          }
        }
        var localGeocoderRes = [];
        if (this.options.localGeocoder) {
          localGeocoderRes = this.options.localGeocoder(searchInput);
          if (!localGeocoderRes) {
            localGeocoderRes = [];
          }
        }
        var externalGeocoderRes = [];
        request.catch(
          function(error) {
            geocoderError = error;
          }.bind(this)
        ).then(
          function(response) {
            this._loadingEl.style.display = "none";
            var res = {};
            if (!response) {
              res = {
                type: "FeatureCollection",
                features: []
              };
            } else {
              res = response;
            }
            res.config = config;
            if (this.fresh) {
              this.fresh = false;
            }
            res.features = res.features ? localGeocoderRes.concat(res.features) : localGeocoderRes;
            if (this.options.externalGeocoder) {
              externalGeocoderRes = this.options.externalGeocoder(
                searchInput,
                res.features,
                config
              ) || [];
              return externalGeocoderRes.then(
                function(features) {
                  res.features = res.features ? features.concat(res.features) : features;
                  return res;
                },
                function() {
                  return res;
                }
              );
            }
            return res;
          }.bind(this)
        ).then(
          function(res) {
            if (geocoderError) {
              throw geocoderError;
            }
            if (this.options.filter && res.features.length) {
              res.features = res.features.filter(this.options.filter);
            }
            var results = [];
            if (res.suggestions) {
              results = res.suggestions;
            } else if (res.place) {
              results = [res.place];
            } else {
              results = res.features;
            }
            if (results.length) {
              this._clearEl.style.display = "block";
              this._typeahead.update(results);
              if ((!this.options.showResultsWhileTyping || isSuggestion) && this.options.showResultMarkers && (res.features.length > 0 || res.place)) {
                this._fitBoundsForMarkers();
              }
              this._eventEmitter.emit("results", res);
            } else {
              this._clearEl.style.display = "none";
              this._typeahead.selected = null;
              this._renderNoResults();
              this._eventEmitter.emit("results", res);
            }
          }.bind(this)
        ).catch(
          function(err) {
            this._loadingEl.style.display = "none";
            if (localGeocoderRes.length && this.options.localGeocoder || externalGeocoderRes.length && this.options.externalGeocoder) {
              this._clearEl.style.display = "block";
              this._typeahead.update(localGeocoderRes);
            } else {
              this._clearEl.style.display = "none";
              this._typeahead.selected = null;
              this._renderError();
            }
            this._eventEmitter.emit("results", { features: localGeocoderRes });
            this._eventEmitter.emit("error", { error: err });
          }.bind(this)
        );
        return request;
      },
      _clear: function(ev) {
        if (ev)
          ev.preventDefault();
        this._inputEl.value = "";
        this._typeahead.selected = null;
        this._typeahead.clear();
        this._onChange();
        this._clearEl.style.display = "none";
        this._removeMarker();
        this._removeResultMarkers();
        this.lastSelected = null;
        this._eventEmitter.emit("clear");
        this.fresh = true;
      },
      clear: function(ev) {
        this._clear(ev);
        this._inputEl.focus();
      },
      _clearOnBlur: function(ev) {
        var ctx = this;
        if (ev.relatedTarget) {
          ctx._clear(ev);
        }
      },
      _onQueryResult: function(response) {
        var results = response;
        if (!results.features.length)
          return;
        var result = results.features[0];
        this._typeahead.selected = result;
        this._inputEl.value = result.place_name;
        this._onChange();
      },
      _updateProximity: function() {
        if (!this._map) {
          return;
        }
        if (this._map.getZoom() > 9) {
          var center = this._map.getCenter().wrap();
          this.setProximity({ longitude: center.lng, latitude: center.lat });
        } else {
          this.setProximity(null);
        }
      },
      _collapse: function() {
        if (!this._inputEl.value && this._inputEl !== document.activeElement)
          this.container.classList.add(
            "mapboxgl-ctrl-geocoder--collapsed",
            "maplibregl-ctrl-geocoder--collapsed"
          );
      },
      _unCollapse: function() {
        this.container.classList.remove(
          "mapboxgl-ctrl-geocoder--collapsed",
          "maplibregl-ctrl-geocoder--collapsed"
        );
      },
      query: function(searchInput) {
        this._geocode(searchInput).then(this._onQueryResult);
        return this;
      },
      _renderError: function() {
        var errorMessage = "<div class='mapbox-gl-geocoder--error maplibre-gl-geocoder--error'>There was an error reaching the server</div>";
        this._renderMessage(errorMessage);
      },
      _renderNoResults: function() {
        var errorMessage = "<div class='mapbox-gl-geocoder--error mapbox-gl-geocoder--no-results maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>No results found</div>";
        this._renderMessage(errorMessage);
      },
      _renderMessage: function(msg) {
        this._typeahead.update([]);
        this._typeahead.selected = null;
        this._typeahead.clear();
        this._typeahead.renderError(msg);
      },
      _getPlaceholderText: function() {
        if (this.options.placeholder)
          return this.options.placeholder;
        if (this.options.language) {
          var firstLanguage = this.options.language.split(",")[0];
          var language = subtag.language(firstLanguage);
          var localizedValue = localization.placeholder[language];
          if (localizedValue)
            return localizedValue;
        }
        return "Search";
      },
      _fitBoundsForMarkers: function() {
        if (this._typeahead.data.length < 1)
          return;
        var results = this._typeahead.data.filter(function(result) {
          return typeof result === "string" ? false : true;
        }).slice(0, this.options.limit);
        this._clearEl.style.display = "none";
        if (this.options.flyTo && this._maplibregl) {
          if (this._map) {
            var defaultFlyOptions = { padding: 100 };
            var flyOptions = extend({}, defaultFlyOptions, this.options.flyTo);
            var bounds = new this._maplibregl.LngLatBounds();
            results.forEach(function(feature2) {
              bounds.extend(feature2.geometry.coordinates);
            });
            this._map.fitBounds(bounds.toArray(), flyOptions);
          }
        }
        if (results.length > 0 && this._maplibregl) {
          this._handleResultMarkers(results);
        }
        return this;
      },
      setInput: function(searchInput) {
        this._inputEl.value = searchInput;
        this._typeahead.selected = null;
        this._typeahead.clear();
        if (searchInput.length >= this.options.minLength && this.options.showResultsWhileTyping) {
          this._geocode(searchInput);
        }
        return this;
      },
      setProximity: function(proximity) {
        this.options.proximity = proximity;
        return this;
      },
      getProximity: function() {
        return this.options.proximity;
      },
      setRenderFunction: function(fn) {
        if (fn && typeof fn == "function") {
          this._typeahead.render = fn;
        }
        return this;
      },
      getRenderFunction: function() {
        return this._typeahead.render;
      },
      setLanguage: function(language) {
        var browserLocale = navigator.language || navigator.userLanguage || navigator.browserLanguage;
        this.options.language = language || this.options.language || browserLocale;
        return this;
      },
      getLanguage: function() {
        return this.options.language;
      },
      getZoom: function() {
        return this.options.zoom;
      },
      setZoom: function(zoom) {
        this.options.zoom = zoom;
        return this;
      },
      getFlyTo: function() {
        return this.options.flyTo;
      },
      setFlyTo: function(flyTo) {
        this.options.flyTo = flyTo;
        return this;
      },
      getPlaceholder: function() {
        return this.options.placeholder;
      },
      setPlaceholder: function(placeholder) {
        this.placeholder = placeholder ? placeholder : this._getPlaceholderText();
        this._inputEl.placeholder = this.placeholder;
        this._inputEl.setAttribute("aria-label", this.placeholder);
        return this;
      },
      getBbox: function() {
        return this.options.bbox;
      },
      setBbox: function(bbox) {
        this.options.bbox = bbox;
        return this;
      },
      getCountries: function() {
        return this.options.countries;
      },
      setCountries: function(countries) {
        this.options.countries = countries;
        return this;
      },
      getTypes: function() {
        return this.options.types;
      },
      setTypes: function(types) {
        this.options.types = types;
        return this;
      },
      getMinLength: function() {
        return this.options.minLength;
      },
      setMinLength: function(minLength) {
        this.options.minLength = minLength;
        if (this._typeahead)
          this._typeahead.options.minLength = minLength;
        return this;
      },
      getLimit: function() {
        return this.options.limit;
      },
      setLimit: function(limit) {
        this.options.limit = limit;
        if (this._typeahead)
          this._typeahead.options.limit = limit;
        return this;
      },
      getFilter: function() {
        return this.options.filter;
      },
      setFilter: function(filter) {
        this.options.filter = filter;
        return this;
      },
      setGeocoderApi: function(geocoderApi) {
        this.geocoderApi = geocoderApi;
        return this;
      },
      getGeocoderApi: function() {
        return this.geocoderApi;
      },
      _handleMarker: function(selected) {
        if (!this._map) {
          return;
        }
        this._removeMarker();
        var defaultMarkerOptions = {
          color: "#4668F2"
        };
        var markerOptions = extend({}, defaultMarkerOptions, this.options.marker);
        this.mapMarker = new this._maplibregl.Marker(markerOptions);
        var popup;
        if (this.options.popup) {
          var defaultPopupOptions = {};
          var popupOptions = extend({}, defaultPopupOptions, this.options.popup);
          popup = new this._maplibregl.Popup(popupOptions).setHTML(
            this.options.popupRender(selected)
          );
        }
        if (selected.center) {
          this.mapMarker.setLngLat(selected.center).addTo(this._map);
          if (this.options.popup)
            this.mapMarker.setPopup(popup);
        } else if (selected.geometry && selected.geometry.type && selected.geometry.type === "Point" && selected.geometry.coordinates) {
          this.mapMarker.setLngLat(selected.geometry.coordinates).addTo(this._map);
          if (this.options.popup)
            this.mapMarker.setPopup(popup);
        }
        return this;
      },
      _removeMarker: function() {
        if (this.mapMarker) {
          this.mapMarker.remove();
          this.mapMarker = null;
        }
      },
      _handleResultMarkers: function(results) {
        if (!this._map) {
          return;
        }
        this._removeResultMarkers();
        var defaultMarkerOptions = {
          color: "#4668F2"
        };
        var markerOptions = extend(
          {},
          defaultMarkerOptions,
          this.options.showResultMarkers
        );
        results.forEach(
          function(result) {
            if (this.options.showResultMarkers && this.options.showResultMarkers.element) {
              var el = this.options.showResultMarkers.element.cloneNode(true);
              markerOptions = extend(markerOptions, { element: el });
            }
            var marker = new this._maplibregl.Marker(
              extend({}, markerOptions, { element: el })
            );
            var popup;
            if (this.options.popup) {
              var defaultPopupOptions = {};
              var popupOptions = extend(
                {},
                defaultPopupOptions,
                this.options.popup
              );
              popup = new this._maplibregl.Popup(popupOptions).setHTML(
                this.options.popupRender(result)
              );
            }
            if (result.center) {
              marker.setLngLat(result.center).addTo(this._map);
              if (this.options.popup)
                marker.setPopup(popup);
            } else if (result.geometry && result.geometry.type && result.geometry.type === "Point" && result.geometry.coordinates) {
              marker.setLngLat(result.geometry.coordinates).addTo(this._map);
              if (this.options.popup)
                marker.setPopup(popup);
            }
            this.resultMarkers.push(marker);
          }.bind(this)
        );
        return this;
      },
      _removeResultMarkers: function() {
        if (this.resultMarkers && this.resultMarkers.length > 0) {
          this.resultMarkers.forEach(function(marker) {
            marker.remove();
          });
          this.resultMarkers = [];
        }
      },
      on: function(type, fn) {
        this._eventEmitter.on(type, fn);
        return this;
      },
      off: function(type, fn) {
        this._eventEmitter.removeListener(type, fn);
        return this;
      }
    };
    module.exports = MaplibreGeocoder2;
  }
});

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports, module) {
    function debounce2(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      if (null == wait)
        wait = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce2.debounce = debounce2;
    module.exports = debounce2;
  }
});

// node_modules/@mapbox/mapbox-gl-draw/dist/mapbox-gl-draw.js
var require_mapbox_gl_draw = __commonJS({
  "node_modules/@mapbox/mapbox-gl-draw/dist/mapbox-gl-draw.js"(exports, module) {
    !function(t, e2) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define(e2) : (t = t || self).MapboxDraw = e2();
    }(exports, function() {
      "use strict";
      var t = function(t2, e3) {
        var n2 = { drag: [], click: [], mousemove: [], mousedown: [], mouseup: [], mouseout: [], keydown: [], keyup: [], touchstart: [], touchmove: [], touchend: [], tap: [] }, o2 = { on: function(t3, e4, o3) {
          if (void 0 === n2[t3])
            throw new Error("Invalid event type: " + t3);
          n2[t3].push({ selector: e4, fn: o3 });
        }, render: function(t3) {
          e3.store.featureChanged(t3);
        } }, r2 = function(t3, r3) {
          for (var i2 = n2[t3], a2 = i2.length; a2--; ) {
            var s2 = i2[a2];
            if (s2.selector(r3)) {
              s2.fn.call(o2, r3) || e3.store.render(), e3.ui.updateMapClasses();
              break;
            }
          }
        };
        return t2.start.call(o2), { render: t2.render, stop: function() {
          t2.stop && t2.stop();
        }, trash: function() {
          t2.trash && (t2.trash(), e3.store.render());
        }, combineFeatures: function() {
          t2.combineFeatures && t2.combineFeatures();
        }, uncombineFeatures: function() {
          t2.uncombineFeatures && t2.uncombineFeatures();
        }, drag: function(t3) {
          r2("drag", t3);
        }, click: function(t3) {
          r2("click", t3);
        }, mousemove: function(t3) {
          r2("mousemove", t3);
        }, mousedown: function(t3) {
          r2("mousedown", t3);
        }, mouseup: function(t3) {
          r2("mouseup", t3);
        }, mouseout: function(t3) {
          r2("mouseout", t3);
        }, keydown: function(t3) {
          r2("keydown", t3);
        }, keyup: function(t3) {
          r2("keyup", t3);
        }, touchstart: function(t3) {
          r2("touchstart", t3);
        }, touchmove: function(t3) {
          r2("touchmove", t3);
        }, touchend: function(t3) {
          r2("touchend", t3);
        }, tap: function(t3) {
          r2("tap", t3);
        } };
      }, e2 = 6378137;
      function n(t2) {
        var e3 = 0;
        if (t2 && t2.length > 0) {
          e3 += Math.abs(o(t2[0]));
          for (var n2 = 1; n2 < t2.length; n2++)
            e3 -= Math.abs(o(t2[n2]));
        }
        return e3;
      }
      function o(t2) {
        var n2, o2, i2, a2, s2, u2, c2 = 0, l2 = t2.length;
        if (l2 > 2) {
          for (u2 = 0; u2 < l2; u2++)
            u2 === l2 - 2 ? (i2 = l2 - 2, a2 = l2 - 1, s2 = 0) : u2 === l2 - 1 ? (i2 = l2 - 1, a2 = 0, s2 = 1) : (i2 = u2, a2 = u2 + 1, s2 = u2 + 2), n2 = t2[i2], o2 = t2[a2], c2 += (r(t2[s2][0]) - r(n2[0])) * Math.sin(r(o2[1]));
          c2 = c2 * e2 * e2 / 2;
        }
        return c2;
      }
      function r(t2) {
        return t2 * Math.PI / 180;
      }
      var i = { geometry: function t2(e3) {
        var o2, r2 = 0;
        switch (e3.type) {
          case "Polygon":
            return n(e3.coordinates);
          case "MultiPolygon":
            for (o2 = 0; o2 < e3.coordinates.length; o2++)
              r2 += n(e3.coordinates[o2]);
            return r2;
          case "Point":
          case "MultiPoint":
          case "LineString":
          case "MultiLineString":
            return 0;
          case "GeometryCollection":
            for (o2 = 0; o2 < e3.geometries.length; o2++)
              r2 += t2(e3.geometries[o2]);
            return r2;
        }
      }, ring: o }, a = "mapboxgl-ctrl", s = "mapbox-gl-draw_ctrl-draw-btn", u = "mapbox-gl-draw_line", c = "mapbox-gl-draw_polygon", l = "mapbox-gl-draw_point", d = "mapbox-gl-draw_trash", p = "mapbox-gl-draw_combine", f = "mapbox-gl-draw_uncombine", h = "mapboxgl-ctrl-group", g = "active", y = "mapbox-gl-draw_boxselect", v = "mapbox-gl-draw-hot", m = "mapbox-gl-draw-cold", b = "add", _ = "move", S = "drag", x = "pointer", C = "none", E = { POLYGON: "polygon", LINE: "line_string", POINT: "point" }, M = "Feature", w = "Polygon", I = "LineString", L = "Point", P = "FeatureCollection", F = "Multi", O = "MultiPoint", k = "MultiLineString", T = "MultiPolygon", j = { DRAW_LINE_STRING: "draw_line_string", DRAW_POLYGON: "draw_polygon", DRAW_POINT: "draw_point", SIMPLE_SELECT: "simple_select", DIRECT_SELECT: "direct_select", STATIC: "static" }, A = "draw.create", D = "draw.delete", N = "draw.update", U = "draw.selectionchange", R = "draw.modechange", B = "draw.actionable", V = "draw.render", J = "draw.combine", G = "draw.uncombine", z = "move", $ = "change_coordinates", W = "feature", q = "midpoint", Y = "vertex", Z = "true", K = "false", X = ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"], H = { Point: 0, LineString: 1, Polygon: 2 };
      function Q(t2, e3) {
        var n2 = H[t2.geometry.type] - H[e3.geometry.type];
        return 0 === n2 && t2.geometry.type === w ? t2.area - e3.area : n2;
      }
      function tt(t2) {
        if (this._items = {}, this._nums = {}, this._length = t2 ? t2.length : 0, t2)
          for (var e3 = 0, n2 = t2.length; e3 < n2; e3++)
            this.add(t2[e3]), void 0 !== t2[e3] && ("string" == typeof t2[e3] ? this._items[t2[e3]] = e3 : this._nums[t2[e3]] = e3);
      }
      tt.prototype.add = function(t2) {
        return this.has(t2) || (this._length++, "string" == typeof t2 ? this._items[t2] = this._length : this._nums[t2] = this._length), this;
      }, tt.prototype.delete = function(t2) {
        return false === this.has(t2) || (this._length--, delete this._items[t2], delete this._nums[t2]), this;
      }, tt.prototype.has = function(t2) {
        return ("string" == typeof t2 || "number" == typeof t2) && (void 0 !== this._items[t2] || void 0 !== this._nums[t2]);
      }, tt.prototype.values = function() {
        var t2 = this, e3 = [];
        return Object.keys(this._items).forEach(function(n2) {
          e3.push({ k: n2, v: t2._items[n2] });
        }), Object.keys(this._nums).forEach(function(n2) {
          e3.push({ k: JSON.parse(n2), v: t2._nums[n2] });
        }), e3.sort(function(t3, e4) {
          return t3.v - e4.v;
        }).map(function(t3) {
          return t3.k;
        });
      }, tt.prototype.clear = function() {
        return this._length = 0, this._items = {}, this._nums = {}, this;
      };
      var et = [W, q, Y], nt = { click: function(t2, e3, n2) {
        return ot(t2, e3, n2, n2.options.clickBuffer);
      }, touch: function(t2, e3, n2) {
        return ot(t2, e3, n2, n2.options.touchBuffer);
      } };
      function ot(t2, e3, n2, o2) {
        if (null === n2.map)
          return [];
        var r2 = t2 ? function(t3, e4) {
          return void 0 === e4 && (e4 = 0), [[t3.point.x - e4, t3.point.y - e4], [t3.point.x + e4, t3.point.y + e4]];
        }(t2, o2) : e3, a2 = {};
        n2.options.styles && (a2.layers = n2.options.styles.map(function(t3) {
          return t3.id;
        }));
        var s2 = n2.map.queryRenderedFeatures(r2, a2).filter(function(t3) {
          return -1 !== et.indexOf(t3.properties.meta);
        }), u2 = new tt(), c2 = [];
        return s2.forEach(function(t3) {
          var e4 = t3.properties.id;
          u2.has(e4) || (u2.add(e4), c2.push(t3));
        }), function(t3) {
          return t3.map(function(t4) {
            return t4.geometry.type === w && (t4.area = i.geometry({ type: M, property: {}, geometry: t4.geometry })), t4;
          }).sort(Q).map(function(t4) {
            return delete t4.area, t4;
          });
        }(c2);
      }
      function rt(t2, e3) {
        var n2 = nt.click(t2, null, e3), o2 = { mouse: C };
        return n2[0] && (o2.mouse = n2[0].properties.active === Z ? _ : x, o2.feature = n2[0].properties.meta), -1 !== e3.events.currentModeName().indexOf("draw") && (o2.mouse = b), e3.ui.queueMapClasses(o2), e3.ui.updateMapClasses(), n2[0];
      }
      function it(t2, e3) {
        var n2 = t2.x - e3.x, o2 = t2.y - e3.y;
        return Math.sqrt(n2 * n2 + o2 * o2);
      }
      function at(t2, e3, n2) {
        void 0 === n2 && (n2 = {});
        var o2 = null != n2.fineTolerance ? n2.fineTolerance : 4, r2 = null != n2.grossTolerance ? n2.grossTolerance : 12, i2 = null != n2.interval ? n2.interval : 500;
        t2.point = t2.point || e3.point, t2.time = t2.time || e3.time;
        var a2 = it(t2.point, e3.point);
        return a2 < o2 || a2 < r2 && e3.time - t2.time < i2;
      }
      function st(t2, e3, n2) {
        void 0 === n2 && (n2 = {});
        var o2 = null != n2.tolerance ? n2.tolerance : 25, r2 = null != n2.interval ? n2.interval : 250;
        return t2.point = t2.point || e3.point, t2.time = t2.time || e3.time, it(t2.point, e3.point) < o2 && e3.time - t2.time < r2;
      }
      function ut(t2, e3) {
        return t2(e3 = { exports: {} }, e3.exports), e3.exports;
      }
      var ct = ut(function(t2) {
        var e3 = t2.exports = function(t3, n2) {
          if (n2 || (n2 = 16), void 0 === t3 && (t3 = 128), t3 <= 0)
            return "0";
          for (var o2 = Math.log(Math.pow(2, t3)) / Math.log(n2), r2 = 2; o2 === 1 / 0; r2 *= 2)
            o2 = Math.log(Math.pow(2, t3 / r2)) / Math.log(n2) * r2;
          var i2 = o2 - Math.floor(o2), a2 = "";
          for (r2 = 0; r2 < Math.floor(o2); r2++) {
            a2 = Math.floor(Math.random() * n2).toString(n2) + a2;
          }
          if (i2) {
            var s2 = Math.pow(n2, i2);
            a2 = Math.floor(Math.random() * s2).toString(n2) + a2;
          }
          var u2 = parseInt(a2, n2);
          return u2 !== 1 / 0 && u2 >= Math.pow(2, t3) ? e3(t3, n2) : a2;
        };
        e3.rack = function(t3, n2, o2) {
          var r2 = function(r3) {
            var a2 = 0;
            do {
              if (a2++ > 10) {
                if (!o2)
                  throw new Error("too many ID collisions, use more bits");
                t3 += o2;
              }
              var s2 = e3(t3, n2);
            } while (Object.hasOwnProperty.call(i2, s2));
            return i2[s2] = r3, s2;
          }, i2 = r2.hats = {};
          return r2.get = function(t4) {
            return r2.hats[t4];
          }, r2.set = function(t4, e4) {
            return r2.hats[t4] = e4, r2;
          }, r2.bits = t3 || 128, r2.base = n2 || 16, r2;
        };
      }), lt = function(t2, e3) {
        this.ctx = t2, this.properties = e3.properties || {}, this.coordinates = e3.geometry.coordinates, this.id = e3.id || ct(), this.type = e3.geometry.type;
      };
      lt.prototype.changed = function() {
        this.ctx.store.featureChanged(this.id);
      }, lt.prototype.incomingCoords = function(t2) {
        this.setCoordinates(t2);
      }, lt.prototype.setCoordinates = function(t2) {
        this.coordinates = t2, this.changed();
      }, lt.prototype.getCoordinates = function() {
        return JSON.parse(JSON.stringify(this.coordinates));
      }, lt.prototype.setProperty = function(t2, e3) {
        this.properties[t2] = e3;
      }, lt.prototype.toGeoJSON = function() {
        return JSON.parse(JSON.stringify({ id: this.id, type: M, properties: this.properties, geometry: { coordinates: this.getCoordinates(), type: this.type } }));
      }, lt.prototype.internal = function(t2) {
        var e3 = { id: this.id, meta: W, "meta:type": this.type, active: K, mode: t2 };
        if (this.ctx.options.userProperties)
          for (var n2 in this.properties)
            e3["user_" + n2] = this.properties[n2];
        return { type: M, properties: e3, geometry: { coordinates: this.getCoordinates(), type: this.type } };
      };
      var dt = function(t2, e3) {
        lt.call(this, t2, e3);
      };
      (dt.prototype = Object.create(lt.prototype)).isValid = function() {
        return "number" == typeof this.coordinates[0] && "number" == typeof this.coordinates[1];
      }, dt.prototype.updateCoordinate = function(t2, e3, n2) {
        this.coordinates = 3 === arguments.length ? [e3, n2] : [t2, e3], this.changed();
      }, dt.prototype.getCoordinate = function() {
        return this.getCoordinates();
      };
      var pt = function(t2, e3) {
        lt.call(this, t2, e3);
      };
      (pt.prototype = Object.create(lt.prototype)).isValid = function() {
        return this.coordinates.length > 1;
      }, pt.prototype.addCoordinate = function(t2, e3, n2) {
        this.changed();
        var o2 = parseInt(t2, 10);
        this.coordinates.splice(o2, 0, [e3, n2]);
      }, pt.prototype.getCoordinate = function(t2) {
        var e3 = parseInt(t2, 10);
        return JSON.parse(JSON.stringify(this.coordinates[e3]));
      }, pt.prototype.removeCoordinate = function(t2) {
        this.changed(), this.coordinates.splice(parseInt(t2, 10), 1);
      }, pt.prototype.updateCoordinate = function(t2, e3, n2) {
        var o2 = parseInt(t2, 10);
        this.coordinates[o2] = [e3, n2], this.changed();
      };
      var ft = function(t2, e3) {
        lt.call(this, t2, e3), this.coordinates = this.coordinates.map(function(t3) {
          return t3.slice(0, -1);
        });
      };
      (ft.prototype = Object.create(lt.prototype)).isValid = function() {
        return 0 !== this.coordinates.length && this.coordinates.every(function(t2) {
          return t2.length > 2;
        });
      }, ft.prototype.incomingCoords = function(t2) {
        this.coordinates = t2.map(function(t3) {
          return t3.slice(0, -1);
        }), this.changed();
      }, ft.prototype.setCoordinates = function(t2) {
        this.coordinates = t2, this.changed();
      }, ft.prototype.addCoordinate = function(t2, e3, n2) {
        this.changed();
        var o2 = t2.split(".").map(function(t3) {
          return parseInt(t3, 10);
        });
        this.coordinates[o2[0]].splice(o2[1], 0, [e3, n2]);
      }, ft.prototype.removeCoordinate = function(t2) {
        this.changed();
        var e3 = t2.split(".").map(function(t3) {
          return parseInt(t3, 10);
        }), n2 = this.coordinates[e3[0]];
        n2 && (n2.splice(e3[1], 1), n2.length < 3 && this.coordinates.splice(e3[0], 1));
      }, ft.prototype.getCoordinate = function(t2) {
        var e3 = t2.split(".").map(function(t3) {
          return parseInt(t3, 10);
        }), n2 = this.coordinates[e3[0]];
        return JSON.parse(JSON.stringify(n2[e3[1]]));
      }, ft.prototype.getCoordinates = function() {
        return this.coordinates.map(function(t2) {
          return t2.concat([t2[0]]);
        });
      }, ft.prototype.updateCoordinate = function(t2, e3, n2) {
        this.changed();
        var o2 = t2.split("."), r2 = parseInt(o2[0], 10), i2 = parseInt(o2[1], 10);
        void 0 === this.coordinates[r2] && (this.coordinates[r2] = []), this.coordinates[r2][i2] = [e3, n2];
      };
      var ht = { MultiPoint: dt, MultiLineString: pt, MultiPolygon: ft }, gt = function(t2, e3, n2, o2, r2) {
        var i2 = n2.split("."), a2 = parseInt(i2[0], 10), s2 = i2[1] ? i2.slice(1).join(".") : null;
        return t2[a2][e3](s2, o2, r2);
      }, yt = function(t2, e3) {
        if (lt.call(this, t2, e3), delete this.coordinates, this.model = ht[e3.geometry.type], void 0 === this.model)
          throw new TypeError(e3.geometry.type + " is not a valid type");
        this.features = this._coordinatesToFeatures(e3.geometry.coordinates);
      };
      function vt(t2) {
        this.map = t2.map, this.drawConfig = JSON.parse(JSON.stringify(t2.options || {})), this._ctx = t2;
      }
      (yt.prototype = Object.create(lt.prototype))._coordinatesToFeatures = function(t2) {
        var e3 = this, n2 = this.model.bind(this);
        return t2.map(function(t3) {
          return new n2(e3.ctx, { id: ct(), type: M, properties: {}, geometry: { coordinates: t3, type: e3.type.replace("Multi", "") } });
        });
      }, yt.prototype.isValid = function() {
        return this.features.every(function(t2) {
          return t2.isValid();
        });
      }, yt.prototype.setCoordinates = function(t2) {
        this.features = this._coordinatesToFeatures(t2), this.changed();
      }, yt.prototype.getCoordinate = function(t2) {
        return gt(this.features, "getCoordinate", t2);
      }, yt.prototype.getCoordinates = function() {
        return JSON.parse(JSON.stringify(this.features.map(function(t2) {
          return t2.type === w ? t2.getCoordinates() : t2.coordinates;
        })));
      }, yt.prototype.updateCoordinate = function(t2, e3, n2) {
        gt(this.features, "updateCoordinate", t2, e3, n2), this.changed();
      }, yt.prototype.addCoordinate = function(t2, e3, n2) {
        gt(this.features, "addCoordinate", t2, e3, n2), this.changed();
      }, yt.prototype.removeCoordinate = function(t2) {
        gt(this.features, "removeCoordinate", t2), this.changed();
      }, yt.prototype.getFeatures = function() {
        return this.features;
      }, vt.prototype.setSelected = function(t2) {
        return this._ctx.store.setSelected(t2);
      }, vt.prototype.setSelectedCoordinates = function(t2) {
        var e3 = this;
        this._ctx.store.setSelectedCoordinates(t2), t2.reduce(function(t3, n2) {
          return void 0 === t3[n2.feature_id] && (t3[n2.feature_id] = true, e3._ctx.store.get(n2.feature_id).changed()), t3;
        }, {});
      }, vt.prototype.getSelected = function() {
        return this._ctx.store.getSelected();
      }, vt.prototype.getSelectedIds = function() {
        return this._ctx.store.getSelectedIds();
      }, vt.prototype.isSelected = function(t2) {
        return this._ctx.store.isSelected(t2);
      }, vt.prototype.getFeature = function(t2) {
        return this._ctx.store.get(t2);
      }, vt.prototype.select = function(t2) {
        return this._ctx.store.select(t2);
      }, vt.prototype.deselect = function(t2) {
        return this._ctx.store.deselect(t2);
      }, vt.prototype.deleteFeature = function(t2, e3) {
        return void 0 === e3 && (e3 = {}), this._ctx.store.delete(t2, e3);
      }, vt.prototype.addFeature = function(t2) {
        return this._ctx.store.add(t2);
      }, vt.prototype.clearSelectedFeatures = function() {
        return this._ctx.store.clearSelected();
      }, vt.prototype.clearSelectedCoordinates = function() {
        return this._ctx.store.clearSelectedCoordinates();
      }, vt.prototype.setActionableState = function(t2) {
        void 0 === t2 && (t2 = {});
        var e3 = { trash: t2.trash || false, combineFeatures: t2.combineFeatures || false, uncombineFeatures: t2.uncombineFeatures || false };
        return this._ctx.events.actionable(e3);
      }, vt.prototype.changeMode = function(t2, e3, n2) {
        return void 0 === e3 && (e3 = {}), void 0 === n2 && (n2 = {}), this._ctx.events.changeMode(t2, e3, n2);
      }, vt.prototype.updateUIClasses = function(t2) {
        return this._ctx.ui.queueMapClasses(t2);
      }, vt.prototype.activateUIButton = function(t2) {
        return this._ctx.ui.setActiveButton(t2);
      }, vt.prototype.featuresAt = function(t2, e3, n2) {
        if (void 0 === n2 && (n2 = "click"), "click" !== n2 && "touch" !== n2)
          throw new Error("invalid buffer type");
        return nt[n2](t2, e3, this._ctx);
      }, vt.prototype.newFeature = function(t2) {
        var e3 = t2.geometry.type;
        return e3 === L ? new dt(this._ctx, t2) : e3 === I ? new pt(this._ctx, t2) : e3 === w ? new ft(this._ctx, t2) : new yt(this._ctx, t2);
      }, vt.prototype.isInstanceOf = function(t2, e3) {
        if (t2 === L)
          return e3 instanceof dt;
        if (t2 === I)
          return e3 instanceof pt;
        if (t2 === w)
          return e3 instanceof ft;
        if ("MultiFeature" === t2)
          return e3 instanceof yt;
        throw new Error("Unknown feature class: " + t2);
      }, vt.prototype.doRender = function(t2) {
        return this._ctx.store.featureChanged(t2);
      }, vt.prototype.onSetup = function() {
      }, vt.prototype.onDrag = function() {
      }, vt.prototype.onClick = function() {
      }, vt.prototype.onMouseMove = function() {
      }, vt.prototype.onMouseDown = function() {
      }, vt.prototype.onMouseUp = function() {
      }, vt.prototype.onMouseOut = function() {
      }, vt.prototype.onKeyUp = function() {
      }, vt.prototype.onKeyDown = function() {
      }, vt.prototype.onTouchStart = function() {
      }, vt.prototype.onTouchMove = function() {
      }, vt.prototype.onTouchEnd = function() {
      }, vt.prototype.onTap = function() {
      }, vt.prototype.onStop = function() {
      }, vt.prototype.onTrash = function() {
      }, vt.prototype.onCombineFeature = function() {
      }, vt.prototype.onUncombineFeature = function() {
      }, vt.prototype.toDisplayFeatures = function() {
        throw new Error("You must overwrite toDisplayFeatures");
      };
      var mt = { drag: "onDrag", click: "onClick", mousemove: "onMouseMove", mousedown: "onMouseDown", mouseup: "onMouseUp", mouseout: "onMouseOut", keyup: "onKeyUp", keydown: "onKeyDown", touchstart: "onTouchStart", touchmove: "onTouchMove", touchend: "onTouchEnd", tap: "onTap" }, bt = Object.keys(mt);
      function _t(t2) {
        var e3 = Object.keys(t2);
        return function(n2, o2) {
          void 0 === o2 && (o2 = {});
          var r2 = {}, i2 = e3.reduce(function(e4, n3) {
            return e4[n3] = t2[n3], e4;
          }, new vt(n2));
          return { start: function() {
            var e4 = this;
            r2 = i2.onSetup(o2), bt.forEach(function(n3) {
              var o3, a2 = mt[n3], s2 = function() {
                return false;
              };
              t2[a2] && (s2 = function() {
                return true;
              }), e4.on(n3, s2, (o3 = a2, function(t3) {
                return i2[o3](r2, t3);
              }));
            });
          }, stop: function() {
            i2.onStop(r2);
          }, trash: function() {
            i2.onTrash(r2);
          }, combineFeatures: function() {
            i2.onCombineFeatures(r2);
          }, uncombineFeatures: function() {
            i2.onUncombineFeatures(r2);
          }, render: function(t3, e4) {
            i2.toDisplayFeatures(r2, t3, e4);
          } };
        };
      }
      function St(t2) {
        return [].concat(t2).filter(function(t3) {
          return void 0 !== t3;
        });
      }
      function xt() {
        var t2 = this;
        if (!(t2.ctx.map && void 0 !== t2.ctx.map.getSource(v)))
          return u2();
        var e3 = t2.ctx.events.currentModeName();
        t2.ctx.ui.queueMapClasses({ mode: e3 });
        var n2 = [], o2 = [];
        t2.isDirty ? o2 = t2.getAllIds() : (n2 = t2.getChangedIds().filter(function(e4) {
          return void 0 !== t2.get(e4);
        }), o2 = t2.sources.hot.filter(function(e4) {
          return e4.properties.id && -1 === n2.indexOf(e4.properties.id) && void 0 !== t2.get(e4.properties.id);
        }).map(function(t3) {
          return t3.properties.id;
        })), t2.sources.hot = [];
        var r2 = t2.sources.cold.length;
        t2.sources.cold = t2.isDirty ? [] : t2.sources.cold.filter(function(t3) {
          var e4 = t3.properties.id || t3.properties.parent;
          return -1 === n2.indexOf(e4);
        });
        var i2 = r2 !== t2.sources.cold.length || o2.length > 0;
        function a2(n3, o3) {
          var r3 = t2.get(n3).internal(e3);
          t2.ctx.events.currentModeRender(r3, function(e4) {
            t2.sources[o3].push(e4);
          });
        }
        if (n2.forEach(function(t3) {
          return a2(t3, "hot");
        }), o2.forEach(function(t3) {
          return a2(t3, "cold");
        }), i2 && t2.ctx.map.getSource(m).setData({ type: P, features: t2.sources.cold }), t2.ctx.map.getSource(v).setData({ type: P, features: t2.sources.hot }), t2._emitSelectionChange && (t2.ctx.map.fire(U, { features: t2.getSelected().map(function(t3) {
          return t3.toGeoJSON();
        }), points: t2.getSelectedCoordinates().map(function(t3) {
          return { type: M, properties: {}, geometry: { type: L, coordinates: t3.coordinates } };
        }) }), t2._emitSelectionChange = false), t2._deletedFeaturesToEmit.length) {
          var s2 = t2._deletedFeaturesToEmit.map(function(t3) {
            return t3.toGeoJSON();
          });
          t2._deletedFeaturesToEmit = [], t2.ctx.map.fire(D, { features: s2 });
        }
        function u2() {
          t2.isDirty = false, t2.clearChangedIds();
        }
        u2(), t2.ctx.map.fire(V, {});
      }
      function Ct(t2) {
        var e3, n2 = this;
        this._features = {}, this._featureIds = new tt(), this._selectedFeatureIds = new tt(), this._selectedCoordinates = [], this._changedFeatureIds = new tt(), this._deletedFeaturesToEmit = [], this._emitSelectionChange = false, this._mapInitialConfig = {}, this.ctx = t2, this.sources = { hot: [], cold: [] }, this.render = function() {
          e3 || (e3 = requestAnimationFrame(function() {
            e3 = null, xt.call(n2);
          }));
        }, this.isDirty = false;
      }
      function Et(t2, e3) {
        var n2 = t2._selectedCoordinates.filter(function(e4) {
          return t2._selectedFeatureIds.has(e4.feature_id);
        });
        t2._selectedCoordinates.length === n2.length || e3.silent || (t2._emitSelectionChange = true), t2._selectedCoordinates = n2;
      }
      Ct.prototype.createRenderBatch = function() {
        var t2 = this, e3 = this.render, n2 = 0;
        return this.render = function() {
          n2++;
        }, function() {
          t2.render = e3, n2 > 0 && t2.render();
        };
      }, Ct.prototype.setDirty = function() {
        return this.isDirty = true, this;
      }, Ct.prototype.featureChanged = function(t2) {
        return this._changedFeatureIds.add(t2), this;
      }, Ct.prototype.getChangedIds = function() {
        return this._changedFeatureIds.values();
      }, Ct.prototype.clearChangedIds = function() {
        return this._changedFeatureIds.clear(), this;
      }, Ct.prototype.getAllIds = function() {
        return this._featureIds.values();
      }, Ct.prototype.add = function(t2) {
        return this.featureChanged(t2.id), this._features[t2.id] = t2, this._featureIds.add(t2.id), this;
      }, Ct.prototype.delete = function(t2, e3) {
        var n2 = this;
        return void 0 === e3 && (e3 = {}), St(t2).forEach(function(t3) {
          n2._featureIds.has(t3) && (n2._featureIds.delete(t3), n2._selectedFeatureIds.delete(t3), e3.silent || -1 === n2._deletedFeaturesToEmit.indexOf(n2._features[t3]) && n2._deletedFeaturesToEmit.push(n2._features[t3]), delete n2._features[t3], n2.isDirty = true);
        }), Et(this, e3), this;
      }, Ct.prototype.get = function(t2) {
        return this._features[t2];
      }, Ct.prototype.getAll = function() {
        var t2 = this;
        return Object.keys(this._features).map(function(e3) {
          return t2._features[e3];
        });
      }, Ct.prototype.select = function(t2, e3) {
        var n2 = this;
        return void 0 === e3 && (e3 = {}), St(t2).forEach(function(t3) {
          n2._selectedFeatureIds.has(t3) || (n2._selectedFeatureIds.add(t3), n2._changedFeatureIds.add(t3), e3.silent || (n2._emitSelectionChange = true));
        }), this;
      }, Ct.prototype.deselect = function(t2, e3) {
        var n2 = this;
        return void 0 === e3 && (e3 = {}), St(t2).forEach(function(t3) {
          n2._selectedFeatureIds.has(t3) && (n2._selectedFeatureIds.delete(t3), n2._changedFeatureIds.add(t3), e3.silent || (n2._emitSelectionChange = true));
        }), Et(this, e3), this;
      }, Ct.prototype.clearSelected = function(t2) {
        return void 0 === t2 && (t2 = {}), this.deselect(this._selectedFeatureIds.values(), { silent: t2.silent }), this;
      }, Ct.prototype.setSelected = function(t2, e3) {
        var n2 = this;
        return void 0 === e3 && (e3 = {}), t2 = St(t2), this.deselect(this._selectedFeatureIds.values().filter(function(e4) {
          return -1 === t2.indexOf(e4);
        }), { silent: e3.silent }), this.select(t2.filter(function(t3) {
          return !n2._selectedFeatureIds.has(t3);
        }), { silent: e3.silent }), this;
      }, Ct.prototype.setSelectedCoordinates = function(t2) {
        return this._selectedCoordinates = t2, this._emitSelectionChange = true, this;
      }, Ct.prototype.clearSelectedCoordinates = function() {
        return this._selectedCoordinates = [], this._emitSelectionChange = true, this;
      }, Ct.prototype.getSelectedIds = function() {
        return this._selectedFeatureIds.values();
      }, Ct.prototype.getSelected = function() {
        var t2 = this;
        return this._selectedFeatureIds.values().map(function(e3) {
          return t2.get(e3);
        });
      }, Ct.prototype.getSelectedCoordinates = function() {
        var t2 = this;
        return this._selectedCoordinates.map(function(e3) {
          return { coordinates: t2.get(e3.feature_id).getCoordinate(e3.coord_path) };
        });
      }, Ct.prototype.isSelected = function(t2) {
        return this._selectedFeatureIds.has(t2);
      }, Ct.prototype.setFeatureProperty = function(t2, e3, n2) {
        this.get(t2).setProperty(e3, n2), this.featureChanged(t2);
      }, Ct.prototype.storeMapConfig = function() {
        var t2 = this;
        X.forEach(function(e3) {
          t2.ctx.map[e3] && (t2._mapInitialConfig[e3] = t2.ctx.map[e3].isEnabled());
        });
      }, Ct.prototype.restoreMapConfig = function() {
        var t2 = this;
        Object.keys(this._mapInitialConfig).forEach(function(e3) {
          t2._mapInitialConfig[e3] ? t2.ctx.map[e3].enable() : t2.ctx.map[e3].disable();
        });
      }, Ct.prototype.getInitialConfigValue = function(t2) {
        return void 0 === this._mapInitialConfig[t2] || this._mapInitialConfig[t2];
      };
      var Mt = function() {
        for (var t2 = arguments, e3 = {}, n2 = 0; n2 < arguments.length; n2++) {
          var o2 = t2[n2];
          for (var r2 in o2)
            wt.call(o2, r2) && (e3[r2] = o2[r2]);
        }
        return e3;
      }, wt = Object.prototype.hasOwnProperty;
      var It = ["mode", "feature", "mouse"];
      function Lt(e3) {
        var n2 = null, o2 = null, r2 = { onRemove: function() {
          return e3.map.off("load", r2.connect), clearInterval(o2), r2.removeLayers(), e3.store.restoreMapConfig(), e3.ui.removeButtons(), e3.events.removeEventListeners(), e3.ui.clearMapClasses(), e3.map = null, e3.container = null, e3.store = null, n2 && n2.parentNode && n2.parentNode.removeChild(n2), n2 = null, this;
        }, connect: function() {
          e3.map.off("load", r2.connect), clearInterval(o2), r2.addLayers(), e3.store.storeMapConfig(), e3.events.addEventListeners();
        }, onAdd: function(i2) {
          var y2 = i2.fire;
          return i2.fire = function(t2, e4) {
            var n3 = arguments;
            return 1 === y2.length && 1 !== arguments.length && (n3 = [Mt({}, { type: t2 }, e4)]), y2.apply(i2, n3);
          }, e3.map = i2, e3.events = function(e4) {
            var n3 = Object.keys(e4.options.modes).reduce(function(t2, n4) {
              return t2[n4] = _t(e4.options.modes[n4]), t2;
            }, {}), o3 = {}, r3 = {}, i3 = {}, a2 = null, s2 = null;
            i3.drag = function(t2, n4) {
              n4({ point: t2.point, time: new Date().getTime() }) ? (e4.ui.queueMapClasses({ mouse: S }), s2.drag(t2)) : t2.originalEvent.stopPropagation();
            }, i3.mousedrag = function(t2) {
              i3.drag(t2, function(t3) {
                return !at(o3, t3);
              });
            }, i3.touchdrag = function(t2) {
              i3.drag(t2, function(t3) {
                return !st(r3, t3);
              });
            }, i3.mousemove = function(t2) {
              if (1 === (void 0 !== t2.originalEvent.buttons ? t2.originalEvent.buttons : t2.originalEvent.which))
                return i3.mousedrag(t2);
              var n4 = rt(t2, e4);
              t2.featureTarget = n4, s2.mousemove(t2);
            }, i3.mousedown = function(t2) {
              o3 = { time: new Date().getTime(), point: t2.point };
              var n4 = rt(t2, e4);
              t2.featureTarget = n4, s2.mousedown(t2);
            }, i3.mouseup = function(t2) {
              var n4 = rt(t2, e4);
              t2.featureTarget = n4, at(o3, { point: t2.point, time: new Date().getTime() }) ? s2.click(t2) : s2.mouseup(t2);
            }, i3.mouseout = function(t2) {
              s2.mouseout(t2);
            }, i3.touchstart = function(t2) {
              if (t2.originalEvent.preventDefault(), e4.options.touchEnabled) {
                r3 = { time: new Date().getTime(), point: t2.point };
                var n4 = nt.touch(t2, null, e4)[0];
                t2.featureTarget = n4, s2.touchstart(t2);
              }
            }, i3.touchmove = function(t2) {
              if (t2.originalEvent.preventDefault(), e4.options.touchEnabled)
                return s2.touchmove(t2), i3.touchdrag(t2);
            }, i3.touchend = function(t2) {
              if (t2.originalEvent.preventDefault(), e4.options.touchEnabled) {
                var n4 = nt.touch(t2, null, e4)[0];
                t2.featureTarget = n4, st(r3, { time: new Date().getTime(), point: t2.point }) ? s2.tap(t2) : s2.touchend(t2);
              }
            };
            var u2 = function(t2) {
              return !(8 === t2 || 46 === t2 || t2 >= 48 && t2 <= 57);
            };
            function c2(o4, r4, i4) {
              void 0 === i4 && (i4 = {}), s2.stop();
              var u3 = n3[o4];
              if (void 0 === u3)
                throw new Error(o4 + " is not valid");
              a2 = o4;
              var c3 = u3(e4, r4);
              s2 = t(c3, e4), i4.silent || e4.map.fire(R, { mode: o4 }), e4.store.setDirty(), e4.store.render();
            }
            i3.keydown = function(t2) {
              "mapboxgl-canvas" === (t2.srcElement || t2.target).classList[0] && (8 !== t2.keyCode && 46 !== t2.keyCode || !e4.options.controls.trash ? u2(t2.keyCode) ? s2.keydown(t2) : 49 === t2.keyCode && e4.options.controls.point ? c2(j.DRAW_POINT) : 50 === t2.keyCode && e4.options.controls.line_string ? c2(j.DRAW_LINE_STRING) : 51 === t2.keyCode && e4.options.controls.polygon && c2(j.DRAW_POLYGON) : (t2.preventDefault(), s2.trash()));
            }, i3.keyup = function(t2) {
              u2(t2.keyCode) && s2.keyup(t2);
            }, i3.zoomend = function() {
              e4.store.changeZoom();
            }, i3.data = function(t2) {
              if ("style" === t2.dataType) {
                var n4 = e4.setup, o4 = e4.map, r4 = e4.options, i4 = e4.store;
                r4.styles.some(function(t3) {
                  return o4.getLayer(t3.id);
                }) || (n4.addLayers(), i4.setDirty(), i4.render());
              }
            };
            var l2 = { trash: false, combineFeatures: false, uncombineFeatures: false };
            return { start: function() {
              a2 = e4.options.defaultMode, s2 = t(n3[a2](e4), e4);
            }, changeMode: c2, actionable: function(t2) {
              var n4 = false;
              Object.keys(t2).forEach(function(e5) {
                if (void 0 === l2[e5])
                  throw new Error("Invalid action type");
                l2[e5] !== t2[e5] && (n4 = true), l2[e5] = t2[e5];
              }), n4 && e4.map.fire(B, { actions: l2 });
            }, currentModeName: function() {
              return a2;
            }, currentModeRender: function(t2, e5) {
              return s2.render(t2, e5);
            }, fire: function(t2, e5) {
              i3[t2] && i3[t2](e5);
            }, addEventListeners: function() {
              e4.map.on("mousemove", i3.mousemove), e4.map.on("mousedown", i3.mousedown), e4.map.on("mouseup", i3.mouseup), e4.map.on("data", i3.data), e4.map.on("touchmove", i3.touchmove), e4.map.on("touchstart", i3.touchstart), e4.map.on("touchend", i3.touchend), e4.container.addEventListener("mouseout", i3.mouseout), e4.options.keybindings && (e4.container.addEventListener("keydown", i3.keydown), e4.container.addEventListener("keyup", i3.keyup));
            }, removeEventListeners: function() {
              e4.map.off("mousemove", i3.mousemove), e4.map.off("mousedown", i3.mousedown), e4.map.off("mouseup", i3.mouseup), e4.map.off("data", i3.data), e4.map.off("touchmove", i3.touchmove), e4.map.off("touchstart", i3.touchstart), e4.map.off("touchend", i3.touchend), e4.container.removeEventListener("mouseout", i3.mouseout), e4.options.keybindings && (e4.container.removeEventListener("keydown", i3.keydown), e4.container.removeEventListener("keyup", i3.keyup));
            }, trash: function(t2) {
              s2.trash(t2);
            }, combineFeatures: function() {
              s2.combineFeatures();
            }, uncombineFeatures: function() {
              s2.uncombineFeatures();
            }, getMode: function() {
              return a2;
            } };
          }(e3), e3.ui = function(t2) {
            var e4 = {}, n3 = null, o3 = { mode: null, feature: null, mouse: null }, r3 = { mode: null, feature: null, mouse: null };
            function i3(t3) {
              r3 = Mt(r3, t3);
            }
            function y3() {
              var e5, n4;
              if (t2.container) {
                var i4 = [], a2 = [];
                It.forEach(function(t3) {
                  r3[t3] !== o3[t3] && (i4.push(t3 + "-" + o3[t3]), null !== r3[t3] && a2.push(t3 + "-" + r3[t3]));
                }), i4.length > 0 && (e5 = t2.container.classList).remove.apply(e5, i4), a2.length > 0 && (n4 = t2.container.classList).add.apply(n4, a2), o3 = Mt(o3, r3);
              }
            }
            function v2(t3, e5) {
              void 0 === e5 && (e5 = {});
              var o4 = document.createElement("button");
              return o4.className = s + " " + e5.className, o4.setAttribute("title", e5.title), e5.container.appendChild(o4), o4.addEventListener("click", function(o5) {
                if (o5.preventDefault(), o5.stopPropagation(), o5.target === n3)
                  return m2(), void e5.onDeactivate();
                b2(t3), e5.onActivate();
              }, true), o4;
            }
            function m2() {
              n3 && (n3.classList.remove(g), n3 = null);
            }
            function b2(t3) {
              m2();
              var o4 = e4[t3];
              o4 && o4 && "trash" !== t3 && (o4.classList.add(g), n3 = o4);
            }
            return { setActiveButton: b2, queueMapClasses: i3, updateMapClasses: y3, clearMapClasses: function() {
              i3({ mode: null, feature: null, mouse: null }), y3();
            }, addButtons: function() {
              var n4 = t2.options.controls, o4 = document.createElement("div");
              return o4.className = h + " " + a, n4 ? (n4[E.LINE] && (e4[E.LINE] = v2(E.LINE, { container: o4, className: u, title: "LineString tool " + (t2.options.keybindings ? "(l)" : ""), onActivate: function() {
                return t2.events.changeMode(j.DRAW_LINE_STRING);
              }, onDeactivate: function() {
                return t2.events.trash();
              } })), n4[E.POLYGON] && (e4[E.POLYGON] = v2(E.POLYGON, { container: o4, className: c, title: "Polygon tool " + (t2.options.keybindings ? "(p)" : ""), onActivate: function() {
                return t2.events.changeMode(j.DRAW_POLYGON);
              }, onDeactivate: function() {
                return t2.events.trash();
              } })), n4[E.POINT] && (e4[E.POINT] = v2(E.POINT, { container: o4, className: l, title: "Marker tool " + (t2.options.keybindings ? "(m)" : ""), onActivate: function() {
                return t2.events.changeMode(j.DRAW_POINT);
              }, onDeactivate: function() {
                return t2.events.trash();
              } })), n4.trash && (e4.trash = v2("trash", { container: o4, className: d, title: "Delete", onActivate: function() {
                t2.events.trash();
              } })), n4.combine_features && (e4.combine_features = v2("combineFeatures", { container: o4, className: p, title: "Combine", onActivate: function() {
                t2.events.combineFeatures();
              } })), n4.uncombine_features && (e4.uncombine_features = v2("uncombineFeatures", { container: o4, className: f, title: "Uncombine", onActivate: function() {
                t2.events.uncombineFeatures();
              } })), o4) : o4;
            }, removeButtons: function() {
              Object.keys(e4).forEach(function(t3) {
                var n4 = e4[t3];
                n4.parentNode && n4.parentNode.removeChild(n4), delete e4[t3];
              });
            } };
          }(e3), e3.container = i2.getContainer(), e3.store = new Ct(e3), n2 = e3.ui.addButtons(), e3.options.boxSelect && (i2.boxZoom.disable(), i2.dragPan.disable(), i2.dragPan.enable()), i2.loaded() ? r2.connect() : (i2.on("load", r2.connect), o2 = setInterval(function() {
            i2.loaded() && r2.connect();
          }, 16)), e3.events.start(), n2;
        }, addLayers: function() {
          e3.map.addSource(m, { data: { type: P, features: [] }, type: "geojson" }), e3.map.addSource(v, { data: { type: P, features: [] }, type: "geojson" }), e3.options.styles.forEach(function(t2) {
            e3.map.addLayer(t2);
          }), e3.store.setDirty(true), e3.store.render();
        }, removeLayers: function() {
          e3.options.styles.forEach(function(t2) {
            e3.map.getLayer(t2.id) && e3.map.removeLayer(t2.id);
          }), e3.map.getSource(m) && e3.map.removeSource(m), e3.map.getSource(v) && e3.map.removeSource(v);
        } };
        return e3.setup = r2, r2;
      }
      function Pt(t2) {
        return function(e3) {
          var n2 = e3.featureTarget;
          return !!n2 && (!!n2.properties && n2.properties.meta === t2);
        };
      }
      function Ft(t2) {
        return !!t2.featureTarget && (!!t2.featureTarget.properties && (t2.featureTarget.properties.active === Z && t2.featureTarget.properties.meta === W));
      }
      function Ot(t2) {
        return !!t2.featureTarget && (!!t2.featureTarget.properties && (t2.featureTarget.properties.active === K && t2.featureTarget.properties.meta === W));
      }
      function kt(t2) {
        return void 0 === t2.featureTarget;
      }
      function Tt(t2) {
        var e3 = t2.featureTarget;
        return !!e3 && (!!e3.properties && e3.properties.meta === Y);
      }
      function jt(t2) {
        return !!t2.originalEvent && true === t2.originalEvent.shiftKey;
      }
      function At(t2) {
        return 27 === t2.keyCode;
      }
      function Dt(t2) {
        return 13 === t2.keyCode;
      }
      var Nt = Ut;
      function Ut(t2, e3) {
        this.x = t2, this.y = e3;
      }
      function Rt(t2, e3) {
        var n2 = e3.getBoundingClientRect();
        return new Nt(t2.clientX - n2.left - (e3.clientLeft || 0), t2.clientY - n2.top - (e3.clientTop || 0));
      }
      function Bt(t2, e3, n2, o2) {
        return { type: M, properties: { meta: Y, parent: t2, coord_path: n2, active: o2 ? Z : K }, geometry: { type: L, coordinates: e3 } };
      }
      function Vt(t2, e3, n2) {
        void 0 === e3 && (e3 = {}), void 0 === n2 && (n2 = null);
        var o2, r2 = t2.geometry, i2 = r2.type, a2 = r2.coordinates, s2 = t2.properties && t2.properties.id, u2 = [];
        function c2(t3, n3) {
          var o3 = "", r3 = null;
          t3.forEach(function(t4, i3) {
            var a3 = null != n3 ? n3 + "." + i3 : String(i3), c3 = Bt(s2, t4, a3, l2(a3));
            if (e3.midpoints && r3) {
              var d2 = function(t5, e4, n4) {
                var o4 = e4.geometry.coordinates, r4 = n4.geometry.coordinates;
                if (o4[1] > 85 || o4[1] < -85 || r4[1] > 85 || r4[1] < -85)
                  return null;
                var i4 = { lng: (o4[0] + r4[0]) / 2, lat: (o4[1] + r4[1]) / 2 };
                return { type: M, properties: { meta: q, parent: t5, lng: i4.lng, lat: i4.lat, coord_path: n4.properties.coord_path }, geometry: { type: L, coordinates: [i4.lng, i4.lat] } };
              }(s2, r3, c3);
              d2 && u2.push(d2);
            }
            r3 = c3;
            var p2 = JSON.stringify(t4);
            o3 !== p2 && u2.push(c3), 0 === i3 && (o3 = p2);
          });
        }
        function l2(t3) {
          return !!e3.selectedPaths && -1 !== e3.selectedPaths.indexOf(t3);
        }
        return i2 === L ? u2.push(Bt(s2, a2, n2, l2(n2))) : i2 === w ? a2.forEach(function(t3, e4) {
          c2(t3, null !== n2 ? n2 + "." + e4 : String(e4));
        }) : i2 === I ? c2(a2, n2) : 0 === i2.indexOf(F) && (o2 = i2.replace(F, ""), a2.forEach(function(n3, r3) {
          var i3 = { type: M, properties: t2.properties, geometry: { type: o2, coordinates: n3 } };
          u2 = u2.concat(Vt(i3, e3, r3));
        })), u2;
      }
      Ut.prototype = { clone: function() {
        return new Ut(this.x, this.y);
      }, add: function(t2) {
        return this.clone()._add(t2);
      }, sub: function(t2) {
        return this.clone()._sub(t2);
      }, multByPoint: function(t2) {
        return this.clone()._multByPoint(t2);
      }, divByPoint: function(t2) {
        return this.clone()._divByPoint(t2);
      }, mult: function(t2) {
        return this.clone()._mult(t2);
      }, div: function(t2) {
        return this.clone()._div(t2);
      }, rotate: function(t2) {
        return this.clone()._rotate(t2);
      }, rotateAround: function(t2, e3) {
        return this.clone()._rotateAround(t2, e3);
      }, matMult: function(t2) {
        return this.clone()._matMult(t2);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t2) {
        return this.x === t2.x && this.y === t2.y;
      }, dist: function(t2) {
        return Math.sqrt(this.distSqr(t2));
      }, distSqr: function(t2) {
        var e3 = t2.x - this.x, n2 = t2.y - this.y;
        return e3 * e3 + n2 * n2;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t2) {
        return Math.atan2(this.y - t2.y, this.x - t2.x);
      }, angleWith: function(t2) {
        return this.angleWithSep(t2.x, t2.y);
      }, angleWithSep: function(t2, e3) {
        return Math.atan2(this.x * e3 - this.y * t2, this.x * t2 + this.y * e3);
      }, _matMult: function(t2) {
        var e3 = t2[0] * this.x + t2[1] * this.y, n2 = t2[2] * this.x + t2[3] * this.y;
        return this.x = e3, this.y = n2, this;
      }, _add: function(t2) {
        return this.x += t2.x, this.y += t2.y, this;
      }, _sub: function(t2) {
        return this.x -= t2.x, this.y -= t2.y, this;
      }, _mult: function(t2) {
        return this.x *= t2, this.y *= t2, this;
      }, _div: function(t2) {
        return this.x /= t2, this.y /= t2, this;
      }, _multByPoint: function(t2) {
        return this.x *= t2.x, this.y *= t2.y, this;
      }, _divByPoint: function(t2) {
        return this.x /= t2.x, this.y /= t2.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t2 = this.y;
        return this.y = this.x, this.x = -t2, this;
      }, _rotate: function(t2) {
        var e3 = Math.cos(t2), n2 = Math.sin(t2), o2 = e3 * this.x - n2 * this.y, r2 = n2 * this.x + e3 * this.y;
        return this.x = o2, this.y = r2, this;
      }, _rotateAround: function(t2, e3) {
        var n2 = Math.cos(t2), o2 = Math.sin(t2), r2 = e3.x + n2 * (this.x - e3.x) - o2 * (this.y - e3.y), i2 = e3.y + o2 * (this.x - e3.x) + n2 * (this.y - e3.y);
        return this.x = r2, this.y = i2, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, Ut.convert = function(t2) {
        return t2 instanceof Ut ? t2 : Array.isArray(t2) ? new Ut(t2[0], t2[1]) : t2;
      };
      var Jt = function(t2) {
        setTimeout(function() {
          t2.map && t2.map.doubleClickZoom && t2._ctx && t2._ctx.store && t2._ctx.store.getInitialConfigValue && t2._ctx.store.getInitialConfigValue("doubleClickZoom") && t2.map.doubleClickZoom.enable();
        }, 0);
      }, Gt = function(t2) {
        setTimeout(function() {
          t2.map && t2.map.doubleClickZoom && t2.map.doubleClickZoom.disable();
        }, 0);
      }, zt = function(t2) {
        if (!t2 || !t2.type)
          return null;
        var e3 = $t[t2.type];
        if (!e3)
          return null;
        if ("geometry" === e3)
          return { type: "FeatureCollection", features: [{ type: "Feature", properties: {}, geometry: t2 }] };
        if ("feature" === e3)
          return { type: "FeatureCollection", features: [t2] };
        if ("featurecollection" === e3)
          return t2;
      }, $t = { Point: "geometry", MultiPoint: "geometry", LineString: "geometry", MultiLineString: "geometry", Polygon: "geometry", MultiPolygon: "geometry", GeometryCollection: "geometry", Feature: "feature", FeatureCollection: "featurecollection" };
      function Wt(t2) {
        switch (t2 && t2.type || null) {
          case "FeatureCollection":
            return t2.features = t2.features.reduce(function(t3, e3) {
              return t3.concat(Wt(e3));
            }, []), t2;
          case "Feature":
            return t2.geometry ? Wt(t2.geometry).map(function(e3) {
              var n2 = { type: "Feature", properties: JSON.parse(JSON.stringify(t2.properties)), geometry: e3 };
              return void 0 !== t2.id && (n2.id = t2.id), n2;
            }) : [t2];
          case "MultiPoint":
            return t2.coordinates.map(function(t3) {
              return { type: "Point", coordinates: t3 };
            });
          case "MultiPolygon":
            return t2.coordinates.map(function(t3) {
              return { type: "Polygon", coordinates: t3 };
            });
          case "MultiLineString":
            return t2.coordinates.map(function(t3) {
              return { type: "LineString", coordinates: t3 };
            });
          case "GeometryCollection":
            return t2.geometries.map(Wt).reduce(function(t3, e3) {
              return t3.concat(e3);
            }, []);
          case "Point":
          case "Polygon":
          case "LineString":
            return [t2];
        }
      }
      var qt = function(t2) {
        if (!t2)
          return [];
        var e3 = Wt(zt(t2)), n2 = [];
        return e3.features.forEach(function(t3) {
          t3.geometry && (n2 = n2.concat(function t4(e4) {
            return Array.isArray(e4) && e4.length && "number" == typeof e4[0] ? [e4] : e4.reduce(function(e5, n3) {
              return Array.isArray(n3) && Array.isArray(n3[0]) ? e5.concat(t4(n3)) : (e5.push(n3), e5);
            }, []);
          }(t3.geometry.coordinates)));
        }), n2;
      }, Yt = ut(function(t2) {
        var e3 = t2.exports = function(t3) {
          return new n2(t3);
        };
        function n2(t3) {
          this.value = t3;
        }
        function o2(t3, e4, n3) {
          var o3 = [], a3 = [], l2 = true;
          return function t4(d2) {
            var p2 = n3 ? r2(d2) : d2, f2 = {}, h2 = true, g2 = { node: p2, node_: d2, path: [].concat(o3), parent: a3[a3.length - 1], parents: a3, key: o3.slice(-1)[0], isRoot: 0 === o3.length, level: o3.length, circular: null, update: function(t5, e5) {
              g2.isRoot || (g2.parent.node[g2.key] = t5), g2.node = t5, e5 && (h2 = false);
            }, delete: function(t5) {
              delete g2.parent.node[g2.key], t5 && (h2 = false);
            }, remove: function(t5) {
              s2(g2.parent.node) ? g2.parent.node.splice(g2.key, 1) : delete g2.parent.node[g2.key], t5 && (h2 = false);
            }, keys: null, before: function(t5) {
              f2.before = t5;
            }, after: function(t5) {
              f2.after = t5;
            }, pre: function(t5) {
              f2.pre = t5;
            }, post: function(t5) {
              f2.post = t5;
            }, stop: function() {
              l2 = false;
            }, block: function() {
              h2 = false;
            } };
            if (!l2)
              return g2;
            function y2() {
              if ("object" == typeof g2.node && null !== g2.node) {
                g2.keys && g2.node_ === g2.node || (g2.keys = i2(g2.node)), g2.isLeaf = 0 == g2.keys.length;
                for (var t5 = 0; t5 < a3.length; t5++)
                  if (a3[t5].node_ === d2) {
                    g2.circular = a3[t5];
                    break;
                  }
              } else
                g2.isLeaf = true, g2.keys = null;
              g2.notLeaf = !g2.isLeaf, g2.notRoot = !g2.isRoot;
            }
            y2();
            var v2 = e4.call(g2, g2.node);
            return void 0 !== v2 && g2.update && g2.update(v2), f2.before && f2.before.call(g2, g2.node), h2 ? ("object" != typeof g2.node || null === g2.node || g2.circular || (a3.push(g2), y2(), u2(g2.keys, function(e5, r3) {
              o3.push(e5), f2.pre && f2.pre.call(g2, g2.node[e5], e5);
              var i3 = t4(g2.node[e5]);
              n3 && c2.call(g2.node, e5) && (g2.node[e5] = i3.node), i3.isLast = r3 == g2.keys.length - 1, i3.isFirst = 0 == r3, f2.post && f2.post.call(g2, i3), o3.pop();
            }), a3.pop()), f2.after && f2.after.call(g2, g2.node), g2) : g2;
          }(t3).node;
        }
        function r2(t3) {
          if ("object" == typeof t3 && null !== t3) {
            var e4;
            if (s2(t3))
              e4 = [];
            else if ("[object Date]" === a2(t3))
              e4 = new Date(t3.getTime ? t3.getTime() : t3);
            else if (function(t4) {
              return "[object RegExp]" === a2(t4);
            }(t3))
              e4 = new RegExp(t3);
            else if (function(t4) {
              return "[object Error]" === a2(t4);
            }(t3))
              e4 = { message: t3.message };
            else if (function(t4) {
              return "[object Boolean]" === a2(t4);
            }(t3))
              e4 = new Boolean(t3);
            else if (function(t4) {
              return "[object Number]" === a2(t4);
            }(t3))
              e4 = new Number(t3);
            else if (function(t4) {
              return "[object String]" === a2(t4);
            }(t3))
              e4 = new String(t3);
            else if (Object.create && Object.getPrototypeOf)
              e4 = Object.create(Object.getPrototypeOf(t3));
            else if (t3.constructor === Object)
              e4 = {};
            else {
              var n3 = t3.constructor && t3.constructor.prototype || t3.__proto__ || {}, o3 = function() {
              };
              o3.prototype = n3, e4 = new o3();
            }
            return u2(i2(t3), function(n4) {
              e4[n4] = t3[n4];
            }), e4;
          }
          return t3;
        }
        n2.prototype.get = function(t3) {
          for (var e4 = this.value, n3 = 0; n3 < t3.length; n3++) {
            var o3 = t3[n3];
            if (!e4 || !c2.call(e4, o3)) {
              e4 = void 0;
              break;
            }
            e4 = e4[o3];
          }
          return e4;
        }, n2.prototype.has = function(t3) {
          for (var e4 = this.value, n3 = 0; n3 < t3.length; n3++) {
            var o3 = t3[n3];
            if (!e4 || !c2.call(e4, o3))
              return false;
            e4 = e4[o3];
          }
          return true;
        }, n2.prototype.set = function(t3, e4) {
          for (var n3 = this.value, o3 = 0; o3 < t3.length - 1; o3++) {
            var r3 = t3[o3];
            c2.call(n3, r3) || (n3[r3] = {}), n3 = n3[r3];
          }
          return n3[t3[o3]] = e4, e4;
        }, n2.prototype.map = function(t3) {
          return o2(this.value, t3, true);
        }, n2.prototype.forEach = function(t3) {
          return this.value = o2(this.value, t3, false), this.value;
        }, n2.prototype.reduce = function(t3, e4) {
          var n3 = 1 === arguments.length, o3 = n3 ? this.value : e4;
          return this.forEach(function(e5) {
            this.isRoot && n3 || (o3 = t3.call(this, o3, e5));
          }), o3;
        }, n2.prototype.paths = function() {
          var t3 = [];
          return this.forEach(function(e4) {
            t3.push(this.path);
          }), t3;
        }, n2.prototype.nodes = function() {
          var t3 = [];
          return this.forEach(function(e4) {
            t3.push(this.node);
          }), t3;
        }, n2.prototype.clone = function() {
          var t3 = [], e4 = [];
          return function n3(o3) {
            for (var a3 = 0; a3 < t3.length; a3++)
              if (t3[a3] === o3)
                return e4[a3];
            if ("object" == typeof o3 && null !== o3) {
              var s3 = r2(o3);
              return t3.push(o3), e4.push(s3), u2(i2(o3), function(t4) {
                s3[t4] = n3(o3[t4]);
              }), t3.pop(), e4.pop(), s3;
            }
            return o3;
          }(this.value);
        };
        var i2 = Object.keys || function(t3) {
          var e4 = [];
          for (var n3 in t3)
            e4.push(n3);
          return e4;
        };
        function a2(t3) {
          return Object.prototype.toString.call(t3);
        }
        var s2 = Array.isArray || function(t3) {
          return "[object Array]" === Object.prototype.toString.call(t3);
        }, u2 = function(t3, e4) {
          if (t3.forEach)
            return t3.forEach(e4);
          for (var n3 = 0; n3 < t3.length; n3++)
            e4(t3[n3], n3, t3);
        };
        u2(i2(n2.prototype), function(t3) {
          e3[t3] = function(e4) {
            var o3 = [].slice.call(arguments, 1), r3 = new n2(e4);
            return r3[t3].apply(r3, o3);
          };
        });
        var c2 = Object.hasOwnProperty || function(t3, e4) {
          return e4 in t3;
        };
      }), Zt = Kt;
      function Kt(t2) {
        if (!(this instanceof Kt))
          return new Kt(t2);
        this._bbox = t2 || [1 / 0, 1 / 0, -1 / 0, -1 / 0], this._valid = !!t2;
      }
      Kt.prototype.include = function(t2) {
        return this._valid = true, this._bbox[0] = Math.min(this._bbox[0], t2[0]), this._bbox[1] = Math.min(this._bbox[1], t2[1]), this._bbox[2] = Math.max(this._bbox[2], t2[0]), this._bbox[3] = Math.max(this._bbox[3], t2[1]), this;
      }, Kt.prototype.equals = function(t2) {
        var e3;
        return e3 = t2 instanceof Kt ? t2.bbox() : t2, this._bbox[0] == e3[0] && this._bbox[1] == e3[1] && this._bbox[2] == e3[2] && this._bbox[3] == e3[3];
      }, Kt.prototype.center = function(t2) {
        return this._valid ? [(this._bbox[0] + this._bbox[2]) / 2, (this._bbox[1] + this._bbox[3]) / 2] : null;
      }, Kt.prototype.union = function(t2) {
        var e3;
        return this._valid = true, e3 = t2 instanceof Kt ? t2.bbox() : t2, this._bbox[0] = Math.min(this._bbox[0], e3[0]), this._bbox[1] = Math.min(this._bbox[1], e3[1]), this._bbox[2] = Math.max(this._bbox[2], e3[2]), this._bbox[3] = Math.max(this._bbox[3], e3[3]), this;
      }, Kt.prototype.bbox = function() {
        return this._valid ? this._bbox : null;
      }, Kt.prototype.contains = function(t2) {
        if (!t2)
          return this._fastContains();
        if (!this._valid)
          return null;
        var e3 = t2[0], n2 = t2[1];
        return this._bbox[0] <= e3 && this._bbox[1] <= n2 && this._bbox[2] >= e3 && this._bbox[3] >= n2;
      }, Kt.prototype.intersect = function(t2) {
        return this._valid ? (e3 = t2 instanceof Kt ? t2.bbox() : t2, !(this._bbox[0] > e3[2] || this._bbox[2] < e3[0] || this._bbox[3] < e3[1] || this._bbox[1] > e3[3])) : null;
        var e3;
      }, Kt.prototype._fastContains = function() {
        if (!this._valid)
          return new Function("return null;");
        var t2 = "return " + this._bbox[0] + "<= ll[0] &&" + this._bbox[1] + "<= ll[1] &&" + this._bbox[2] + ">= ll[0] &&" + this._bbox[3] + ">= ll[1]";
        return new Function("ll", t2);
      }, Kt.prototype.polygon = function() {
        return this._valid ? { type: "Polygon", coordinates: [[[this._bbox[0], this._bbox[1]], [this._bbox[2], this._bbox[1]], [this._bbox[2], this._bbox[3]], [this._bbox[0], this._bbox[3]], [this._bbox[0], this._bbox[1]]]] } : null;
      };
      var Xt = { features: ["FeatureCollection"], coordinates: ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], geometry: ["Feature"], geometries: ["GeometryCollection"] }, Ht = Object.keys(Xt), Qt = function(t2) {
        return te(t2).bbox();
      };
      function te(t2) {
        for (var e3 = Zt(), n2 = qt(t2), o2 = 0; o2 < n2.length; o2++)
          e3.include(n2[o2]);
        return e3;
      }
      Qt.polygon = function(t2) {
        return te(t2).polygon();
      }, Qt.bboxify = function(t2) {
        return Yt(t2).map(function(t3) {
          t3 && (Ht.some(function(e3) {
            return !!t3[e3] && -1 !== Xt[e3].indexOf(t3.type);
          }) && (t3.bbox = te(t3).bbox(), this.update(t3)));
        });
      };
      function ee(t2, e3) {
        var n2 = -90, o2 = 90, r2 = -90, i2 = 90, a2 = 270, s2 = -270;
        t2.forEach(function(t3) {
          var e4 = Qt(t3), u3 = e4[1], c2 = e4[3], l2 = e4[0], d2 = e4[2];
          u3 > n2 && (n2 = u3), c2 < o2 && (o2 = c2), c2 > r2 && (r2 = c2), u3 < i2 && (i2 = u3), l2 < a2 && (a2 = l2), d2 > s2 && (s2 = d2);
        });
        var u2 = e3;
        return n2 + u2.lat > 85 && (u2.lat = 85 - n2), r2 + u2.lat > 90 && (u2.lat = 90 - r2), o2 + u2.lat < -85 && (u2.lat = -85 - o2), i2 + u2.lat < -90 && (u2.lat = -90 - i2), a2 + u2.lng <= -270 && (u2.lng += 360 * Math.ceil(Math.abs(u2.lng) / 360)), s2 + u2.lng >= 270 && (u2.lng -= 360 * Math.ceil(Math.abs(u2.lng) / 360)), u2;
      }
      function ne(t2, e3) {
        var n2 = ee(t2.map(function(t3) {
          return t3.toGeoJSON();
        }), e3);
        t2.forEach(function(t3) {
          var e4, o2 = t3.getCoordinates(), r2 = function(t4) {
            var e5 = { lng: t4[0] + n2.lng, lat: t4[1] + n2.lat };
            return [e5.lng, e5.lat];
          }, i2 = function(t4) {
            return t4.map(function(t5) {
              return r2(t5);
            });
          };
          t3.type === L ? e4 = r2(o2) : t3.type === I || t3.type === O ? e4 = o2.map(r2) : t3.type === w || t3.type === k ? e4 = o2.map(i2) : t3.type === T && (e4 = o2.map(function(t4) {
            return t4.map(function(t5) {
              return i2(t5);
            });
          })), t3.incomingCoords(e4);
        });
      }
      var oe = { onSetup: function(t2) {
        var e3 = this, n2 = { dragMoveLocation: null, boxSelectStartLocation: null, boxSelectElement: void 0, boxSelecting: false, canBoxSelect: false, dragMoving: false, canDragMove: false, initiallySelectedFeatureIds: t2.featureIds || [] };
        return this.setSelected(n2.initiallySelectedFeatureIds.filter(function(t3) {
          return void 0 !== e3.getFeature(t3);
        })), this.fireActionable(), this.setActionableState({ combineFeatures: true, uncombineFeatures: true, trash: true }), n2;
      }, fireUpdate: function() {
        this.map.fire(N, { action: z, features: this.getSelected().map(function(t2) {
          return t2.toGeoJSON();
        }) });
      }, fireActionable: function() {
        var t2 = this, e3 = this.getSelected(), n2 = e3.filter(function(e4) {
          return t2.isInstanceOf("MultiFeature", e4);
        }), o2 = false;
        if (e3.length > 1) {
          o2 = true;
          var r2 = e3[0].type.replace("Multi", "");
          e3.forEach(function(t3) {
            t3.type.replace("Multi", "") !== r2 && (o2 = false);
          });
        }
        var i2 = n2.length > 0, a2 = e3.length > 0;
        this.setActionableState({ combineFeatures: o2, uncombineFeatures: i2, trash: a2 });
      }, getUniqueIds: function(t2) {
        return t2.length ? t2.map(function(t3) {
          return t3.properties.id;
        }).filter(function(t3) {
          return void 0 !== t3;
        }).reduce(function(t3, e3) {
          return t3.add(e3), t3;
        }, new tt()).values() : [];
      }, stopExtendedInteractions: function(t2) {
        t2.boxSelectElement && (t2.boxSelectElement.parentNode && t2.boxSelectElement.parentNode.removeChild(t2.boxSelectElement), t2.boxSelectElement = null), this.map.dragPan.enable(), t2.boxSelecting = false, t2.canBoxSelect = false, t2.dragMoving = false, t2.canDragMove = false;
      }, onStop: function() {
        Jt(this);
      }, onMouseMove: function(t2) {
        return this.stopExtendedInteractions(t2), true;
      }, onMouseOut: function(t2) {
        return !t2.dragMoving || this.fireUpdate();
      } };
      oe.onTap = oe.onClick = function(t2, e3) {
        return kt(e3) ? this.clickAnywhere(t2, e3) : Pt(Y)(e3) ? this.clickOnVertex(t2, e3) : function(t3) {
          return !!t3.featureTarget && (!!t3.featureTarget.properties && t3.featureTarget.properties.meta === W);
        }(e3) ? this.clickOnFeature(t2, e3) : void 0;
      }, oe.clickAnywhere = function(t2) {
        var e3 = this, n2 = this.getSelectedIds();
        n2.length && (this.clearSelectedFeatures(), n2.forEach(function(t3) {
          return e3.doRender(t3);
        })), Jt(this), this.stopExtendedInteractions(t2);
      }, oe.clickOnVertex = function(t2, e3) {
        this.changeMode(j.DIRECT_SELECT, { featureId: e3.featureTarget.properties.parent, coordPath: e3.featureTarget.properties.coord_path, startPos: e3.lngLat }), this.updateUIClasses({ mouse: _ });
      }, oe.startOnActiveFeature = function(t2, e3) {
        this.stopExtendedInteractions(t2), this.map.dragPan.disable(), this.doRender(e3.featureTarget.properties.id), t2.canDragMove = true, t2.dragMoveLocation = e3.lngLat;
      }, oe.clickOnFeature = function(t2, e3) {
        var n2 = this;
        Gt(this), this.stopExtendedInteractions(t2);
        var o2 = jt(e3), r2 = this.getSelectedIds(), i2 = e3.featureTarget.properties.id, a2 = this.isSelected(i2);
        if (!o2 && a2 && this.getFeature(i2).type !== L)
          return this.changeMode(j.DIRECT_SELECT, { featureId: i2 });
        a2 && o2 ? (this.deselect(i2), this.updateUIClasses({ mouse: x }), 1 === r2.length && Jt(this)) : !a2 && o2 ? (this.select(i2), this.updateUIClasses({ mouse: _ })) : a2 || o2 || (r2.forEach(function(t3) {
          return n2.doRender(t3);
        }), this.setSelected(i2), this.updateUIClasses({ mouse: _ })), this.doRender(i2);
      }, oe.onMouseDown = function(t2, e3) {
        return Ft(e3) ? this.startOnActiveFeature(t2, e3) : this.drawConfig.boxSelect && function(t3) {
          return !!t3.originalEvent && (!!t3.originalEvent.shiftKey && 0 === t3.originalEvent.button);
        }(e3) ? this.startBoxSelect(t2, e3) : void 0;
      }, oe.startBoxSelect = function(t2, e3) {
        this.stopExtendedInteractions(t2), this.map.dragPan.disable(), t2.boxSelectStartLocation = Rt(e3.originalEvent, this.map.getContainer()), t2.canBoxSelect = true;
      }, oe.onTouchStart = function(t2, e3) {
        if (Ft(e3))
          return this.startOnActiveFeature(t2, e3);
      }, oe.onDrag = function(t2, e3) {
        return t2.canDragMove ? this.dragMove(t2, e3) : this.drawConfig.boxSelect && t2.canBoxSelect ? this.whileBoxSelect(t2, e3) : void 0;
      }, oe.whileBoxSelect = function(t2, e3) {
        t2.boxSelecting = true, this.updateUIClasses({ mouse: b }), t2.boxSelectElement || (t2.boxSelectElement = document.createElement("div"), t2.boxSelectElement.classList.add(y), this.map.getContainer().appendChild(t2.boxSelectElement));
        var n2 = Rt(e3.originalEvent, this.map.getContainer()), o2 = Math.min(t2.boxSelectStartLocation.x, n2.x), r2 = Math.max(t2.boxSelectStartLocation.x, n2.x), i2 = Math.min(t2.boxSelectStartLocation.y, n2.y), a2 = Math.max(t2.boxSelectStartLocation.y, n2.y), s2 = "translate(" + o2 + "px, " + i2 + "px)";
        t2.boxSelectElement.style.transform = s2, t2.boxSelectElement.style.WebkitTransform = s2, t2.boxSelectElement.style.width = r2 - o2 + "px", t2.boxSelectElement.style.height = a2 - i2 + "px";
      }, oe.dragMove = function(t2, e3) {
        t2.dragMoving = true, e3.originalEvent.stopPropagation();
        var n2 = { lng: e3.lngLat.lng - t2.dragMoveLocation.lng, lat: e3.lngLat.lat - t2.dragMoveLocation.lat };
        ne(this.getSelected(), n2), t2.dragMoveLocation = e3.lngLat;
      }, oe.onMouseUp = function(t2, e3) {
        var n2 = this;
        if (t2.dragMoving)
          this.fireUpdate();
        else if (t2.boxSelecting) {
          var o2 = [t2.boxSelectStartLocation, Rt(e3.originalEvent, this.map.getContainer())], r2 = this.featuresAt(null, o2, "click"), i2 = this.getUniqueIds(r2).filter(function(t3) {
            return !n2.isSelected(t3);
          });
          i2.length && (this.select(i2), i2.forEach(function(t3) {
            return n2.doRender(t3);
          }), this.updateUIClasses({ mouse: _ }));
        }
        this.stopExtendedInteractions(t2);
      }, oe.toDisplayFeatures = function(t2, e3, n2) {
        e3.properties.active = this.isSelected(e3.properties.id) ? Z : K, n2(e3), this.fireActionable(), e3.properties.active === Z && e3.geometry.type !== L && Vt(e3).forEach(n2);
      }, oe.onTrash = function() {
        this.deleteFeature(this.getSelectedIds()), this.fireActionable();
      }, oe.onCombineFeatures = function() {
        var t2 = this.getSelected();
        if (!(0 === t2.length || t2.length < 2)) {
          for (var e3 = [], n2 = [], o2 = t2[0].type.replace("Multi", ""), r2 = 0; r2 < t2.length; r2++) {
            var i2 = t2[r2];
            if (i2.type.replace("Multi", "") !== o2)
              return;
            i2.type.includes("Multi") ? i2.getCoordinates().forEach(function(t3) {
              e3.push(t3);
            }) : e3.push(i2.getCoordinates()), n2.push(i2.toGeoJSON());
          }
          if (n2.length > 1) {
            var a2 = this.newFeature({ type: M, properties: n2[0].properties, geometry: { type: "Multi" + o2, coordinates: e3 } });
            this.addFeature(a2), this.deleteFeature(this.getSelectedIds(), { silent: true }), this.setSelected([a2.id]), this.map.fire(J, { createdFeatures: [a2.toGeoJSON()], deletedFeatures: n2 });
          }
          this.fireActionable();
        }
      }, oe.onUncombineFeatures = function() {
        var t2 = this, e3 = this.getSelected();
        if (0 !== e3.length) {
          for (var n2 = [], o2 = [], r2 = function(r3) {
            var i3 = e3[r3];
            t2.isInstanceOf("MultiFeature", i3) && (i3.getFeatures().forEach(function(e4) {
              t2.addFeature(e4), e4.properties = i3.properties, n2.push(e4.toGeoJSON()), t2.select([e4.id]);
            }), t2.deleteFeature(i3.id, { silent: true }), o2.push(i3.toGeoJSON()));
          }, i2 = 0; i2 < e3.length; i2++)
            r2(i2);
          n2.length > 1 && this.map.fire(G, { createdFeatures: n2, deletedFeatures: o2 }), this.fireActionable();
        }
      };
      var re = Pt(Y), ie = Pt(q), ae = { fireUpdate: function() {
        this.map.fire(N, { action: $, features: this.getSelected().map(function(t2) {
          return t2.toGeoJSON();
        }) });
      }, fireActionable: function(t2) {
        this.setActionableState({ combineFeatures: false, uncombineFeatures: false, trash: t2.selectedCoordPaths.length > 0 });
      }, startDragging: function(t2, e3) {
        this.map.dragPan.disable(), t2.canDragMove = true, t2.dragMoveLocation = e3.lngLat;
      }, stopDragging: function(t2) {
        this.map.dragPan.enable(), t2.dragMoving = false, t2.canDragMove = false, t2.dragMoveLocation = null;
      }, onVertex: function(t2, e3) {
        this.startDragging(t2, e3);
        var n2 = e3.featureTarget.properties, o2 = t2.selectedCoordPaths.indexOf(n2.coord_path);
        jt(e3) || -1 !== o2 ? jt(e3) && -1 === o2 && t2.selectedCoordPaths.push(n2.coord_path) : t2.selectedCoordPaths = [n2.coord_path];
        var r2 = this.pathsToCoordinates(t2.featureId, t2.selectedCoordPaths);
        this.setSelectedCoordinates(r2);
      }, onMidpoint: function(t2, e3) {
        this.startDragging(t2, e3);
        var n2 = e3.featureTarget.properties;
        t2.feature.addCoordinate(n2.coord_path, n2.lng, n2.lat), this.fireUpdate(), t2.selectedCoordPaths = [n2.coord_path];
      }, pathsToCoordinates: function(t2, e3) {
        return e3.map(function(e4) {
          return { feature_id: t2, coord_path: e4 };
        });
      }, onFeature: function(t2, e3) {
        0 === t2.selectedCoordPaths.length ? this.startDragging(t2, e3) : this.stopDragging(t2);
      }, dragFeature: function(t2, e3, n2) {
        ne(this.getSelected(), n2), t2.dragMoveLocation = e3.lngLat;
      }, dragVertex: function(t2, e3, n2) {
        for (var o2 = t2.selectedCoordPaths.map(function(e4) {
          return t2.feature.getCoordinate(e4);
        }), r2 = ee(o2.map(function(t3) {
          return { type: M, properties: {}, geometry: { type: L, coordinates: t3 } };
        }), n2), i2 = 0; i2 < o2.length; i2++) {
          var a2 = o2[i2];
          t2.feature.updateCoordinate(t2.selectedCoordPaths[i2], a2[0] + r2.lng, a2[1] + r2.lat);
        }
      }, clickNoTarget: function() {
        this.changeMode(j.SIMPLE_SELECT);
      }, clickInactive: function() {
        this.changeMode(j.SIMPLE_SELECT);
      }, clickActiveFeature: function(t2) {
        t2.selectedCoordPaths = [], this.clearSelectedCoordinates(), t2.feature.changed();
      }, onSetup: function(t2) {
        var e3 = t2.featureId, n2 = this.getFeature(e3);
        if (!n2)
          throw new Error("You must provide a featureId to enter direct_select mode");
        if (n2.type === L)
          throw new TypeError("direct_select mode doesn't handle point features");
        var o2 = { featureId: e3, feature: n2, dragMoveLocation: t2.startPos || null, dragMoving: false, canDragMove: false, selectedCoordPaths: t2.coordPath ? [t2.coordPath] : [] };
        return this.setSelectedCoordinates(this.pathsToCoordinates(e3, o2.selectedCoordPaths)), this.setSelected(e3), Gt(this), this.setActionableState({ trash: true }), o2;
      }, onStop: function() {
        Jt(this), this.clearSelectedCoordinates();
      }, toDisplayFeatures: function(t2, e3, n2) {
        t2.featureId === e3.properties.id ? (e3.properties.active = Z, n2(e3), Vt(e3, { map: this.map, midpoints: true, selectedPaths: t2.selectedCoordPaths }).forEach(n2)) : (e3.properties.active = K, n2(e3)), this.fireActionable(t2);
      }, onTrash: function(t2) {
        t2.selectedCoordPaths.sort(function(t3, e3) {
          return e3.localeCompare(t3, "en", { numeric: true });
        }).forEach(function(e3) {
          return t2.feature.removeCoordinate(e3);
        }), this.fireUpdate(), t2.selectedCoordPaths = [], this.clearSelectedCoordinates(), this.fireActionable(t2), false === t2.feature.isValid() && (this.deleteFeature([t2.featureId]), this.changeMode(j.SIMPLE_SELECT, {}));
      }, onMouseMove: function(t2, e3) {
        var n2 = Ft(e3), o2 = re(e3), r2 = 0 === t2.selectedCoordPaths.length;
        return n2 && r2 || o2 && !r2 ? this.updateUIClasses({ mouse: _ }) : this.updateUIClasses({ mouse: C }), this.stopDragging(t2), true;
      }, onMouseOut: function(t2) {
        return t2.dragMoving && this.fireUpdate(), true;
      } };
      ae.onTouchStart = ae.onMouseDown = function(t2, e3) {
        return re(e3) ? this.onVertex(t2, e3) : Ft(e3) ? this.onFeature(t2, e3) : ie(e3) ? this.onMidpoint(t2, e3) : void 0;
      }, ae.onDrag = function(t2, e3) {
        if (true === t2.canDragMove) {
          t2.dragMoving = true, e3.originalEvent.stopPropagation();
          var n2 = { lng: e3.lngLat.lng - t2.dragMoveLocation.lng, lat: e3.lngLat.lat - t2.dragMoveLocation.lat };
          t2.selectedCoordPaths.length > 0 ? this.dragVertex(t2, e3, n2) : this.dragFeature(t2, e3, n2), t2.dragMoveLocation = e3.lngLat;
        }
      }, ae.onClick = function(t2, e3) {
        return kt(e3) ? this.clickNoTarget(t2, e3) : Ft(e3) ? this.clickActiveFeature(t2, e3) : Ot(e3) ? this.clickInactive(t2, e3) : void this.stopDragging(t2);
      }, ae.onTap = function(t2, e3) {
        return kt(e3) ? this.clickNoTarget(t2, e3) : Ft(e3) ? this.clickActiveFeature(t2, e3) : Ot(e3) ? this.clickInactive(t2, e3) : void 0;
      }, ae.onTouchEnd = ae.onMouseUp = function(t2) {
        t2.dragMoving && this.fireUpdate(), this.stopDragging(t2);
      };
      var se = {};
      function ue(t2, e3) {
        return !!t2.lngLat && (t2.lngLat.lng === e3[0] && t2.lngLat.lat === e3[1]);
      }
      se.onSetup = function() {
        var t2 = this.newFeature({ type: M, properties: {}, geometry: { type: L, coordinates: [] } });
        return this.addFeature(t2), this.clearSelectedFeatures(), this.updateUIClasses({ mouse: b }), this.activateUIButton(E.POINT), this.setActionableState({ trash: true }), { point: t2 };
      }, se.stopDrawingAndRemove = function(t2) {
        this.deleteFeature([t2.point.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT);
      }, se.onTap = se.onClick = function(t2, e3) {
        this.updateUIClasses({ mouse: _ }), t2.point.updateCoordinate("", e3.lngLat.lng, e3.lngLat.lat), this.map.fire(A, { features: [t2.point.toGeoJSON()] }), this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.point.id] });
      }, se.onStop = function(t2) {
        this.activateUIButton(), t2.point.getCoordinate().length || this.deleteFeature([t2.point.id], { silent: true });
      }, se.toDisplayFeatures = function(t2, e3, n2) {
        var o2 = e3.properties.id === t2.point.id;
        if (e3.properties.active = o2 ? Z : K, !o2)
          return n2(e3);
      }, se.onTrash = se.stopDrawingAndRemove, se.onKeyUp = function(t2, e3) {
        if (At(e3) || Dt(e3))
          return this.stopDrawingAndRemove(t2, e3);
      };
      var ce = { onSetup: function() {
        var t2 = this.newFeature({ type: M, properties: {}, geometry: { type: w, coordinates: [[]] } });
        return this.addFeature(t2), this.clearSelectedFeatures(), Gt(this), this.updateUIClasses({ mouse: b }), this.activateUIButton(E.POLYGON), this.setActionableState({ trash: true }), { polygon: t2, currentVertexPosition: 0 };
      }, clickAnywhere: function(t2, e3) {
        if (t2.currentVertexPosition > 0 && ue(e3, t2.polygon.coordinates[0][t2.currentVertexPosition - 1]))
          return this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
        this.updateUIClasses({ mouse: b }), t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), t2.currentVertexPosition++, t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat);
      }, clickOnVertex: function(t2) {
        return this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
      }, onMouseMove: function(t2, e3) {
        t2.polygon.updateCoordinate("0." + t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), Tt(e3) && this.updateUIClasses({ mouse: x });
      } };
      ce.onTap = ce.onClick = function(t2, e3) {
        return Tt(e3) ? this.clickOnVertex(t2, e3) : this.clickAnywhere(t2, e3);
      }, ce.onKeyUp = function(t2, e3) {
        At(e3) ? (this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT)) : Dt(e3) && this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.polygon.id] });
      }, ce.onStop = function(t2) {
        this.updateUIClasses({ mouse: C }), Jt(this), this.activateUIButton(), void 0 !== this.getFeature(t2.polygon.id) && (t2.polygon.removeCoordinate("0." + t2.currentVertexPosition), t2.polygon.isValid() ? this.map.fire(A, { features: [t2.polygon.toGeoJSON()] }) : (this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT, {}, { silent: true })));
      }, ce.toDisplayFeatures = function(t2, e3, n2) {
        var o2 = e3.properties.id === t2.polygon.id;
        if (e3.properties.active = o2 ? Z : K, !o2)
          return n2(e3);
        if (0 !== e3.geometry.coordinates.length) {
          var r2 = e3.geometry.coordinates[0].length;
          if (!(r2 < 3)) {
            if (e3.properties.meta = W, n2(Bt(t2.polygon.id, e3.geometry.coordinates[0][0], "0.0", false)), r2 > 3) {
              var i2 = e3.geometry.coordinates[0].length - 3;
              n2(Bt(t2.polygon.id, e3.geometry.coordinates[0][i2], "0." + i2, false));
            }
            if (r2 <= 4) {
              var a2 = [[e3.geometry.coordinates[0][0][0], e3.geometry.coordinates[0][0][1]], [e3.geometry.coordinates[0][1][0], e3.geometry.coordinates[0][1][1]]];
              if (n2({ type: M, properties: e3.properties, geometry: { coordinates: a2, type: I } }), 3 === r2)
                return;
            }
            return n2(e3);
          }
        }
      }, ce.onTrash = function(t2) {
        this.deleteFeature([t2.polygon.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT);
      };
      var le = { onSetup: function(t2) {
        var e3, n2, o2 = (t2 = t2 || {}).featureId, r2 = "forward";
        if (o2) {
          if (!(e3 = this.getFeature(o2)))
            throw new Error("Could not find a feature with the provided featureId");
          var i2 = t2.from;
          if (i2 && "Feature" === i2.type && i2.geometry && "Point" === i2.geometry.type && (i2 = i2.geometry), i2 && "Point" === i2.type && i2.coordinates && 2 === i2.coordinates.length && (i2 = i2.coordinates), !i2 || !Array.isArray(i2))
            throw new Error("Please use the `from` property to indicate which point to continue the line from");
          var a2 = e3.coordinates.length - 1;
          if (e3.coordinates[a2][0] === i2[0] && e3.coordinates[a2][1] === i2[1])
            n2 = a2 + 1, e3.addCoordinate.apply(e3, [n2].concat(e3.coordinates[a2]));
          else {
            if (e3.coordinates[0][0] !== i2[0] || e3.coordinates[0][1] !== i2[1])
              throw new Error("`from` should match the point at either the start or the end of the provided LineString");
            r2 = "backwards", n2 = 0, e3.addCoordinate.apply(e3, [n2].concat(e3.coordinates[0]));
          }
        } else
          e3 = this.newFeature({ type: M, properties: {}, geometry: { type: I, coordinates: [] } }), n2 = 0, this.addFeature(e3);
        return this.clearSelectedFeatures(), Gt(this), this.updateUIClasses({ mouse: b }), this.activateUIButton(E.LINE), this.setActionableState({ trash: true }), { line: e3, currentVertexPosition: n2, direction: r2 };
      }, clickAnywhere: function(t2, e3) {
        if (t2.currentVertexPosition > 0 && ue(e3, t2.line.coordinates[t2.currentVertexPosition - 1]) || "backwards" === t2.direction && ue(e3, t2.line.coordinates[t2.currentVertexPosition + 1]))
          return this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.line.id] });
        this.updateUIClasses({ mouse: b }), t2.line.updateCoordinate(t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), "forward" === t2.direction ? (t2.currentVertexPosition++, t2.line.updateCoordinate(t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat)) : t2.line.addCoordinate(0, e3.lngLat.lng, e3.lngLat.lat);
      }, clickOnVertex: function(t2) {
        return this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.line.id] });
      }, onMouseMove: function(t2, e3) {
        t2.line.updateCoordinate(t2.currentVertexPosition, e3.lngLat.lng, e3.lngLat.lat), Tt(e3) && this.updateUIClasses({ mouse: x });
      } };
      le.onTap = le.onClick = function(t2, e3) {
        if (Tt(e3))
          return this.clickOnVertex(t2, e3);
        this.clickAnywhere(t2, e3);
      }, le.onKeyUp = function(t2, e3) {
        Dt(e3) ? this.changeMode(j.SIMPLE_SELECT, { featureIds: [t2.line.id] }) : At(e3) && (this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT));
      }, le.onStop = function(t2) {
        Jt(this), this.activateUIButton(), void 0 !== this.getFeature(t2.line.id) && (t2.line.removeCoordinate("" + t2.currentVertexPosition), t2.line.isValid() ? this.map.fire(A, { features: [t2.line.toGeoJSON()] }) : (this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT, {}, { silent: true })));
      }, le.onTrash = function(t2) {
        this.deleteFeature([t2.line.id], { silent: true }), this.changeMode(j.SIMPLE_SELECT);
      }, le.toDisplayFeatures = function(t2, e3, n2) {
        var o2 = e3.properties.id === t2.line.id;
        if (e3.properties.active = o2 ? Z : K, !o2)
          return n2(e3);
        e3.geometry.coordinates.length < 2 || (e3.properties.meta = W, n2(Bt(t2.line.id, e3.geometry.coordinates["forward" === t2.direction ? e3.geometry.coordinates.length - 2 : 1], "" + ("forward" === t2.direction ? e3.geometry.coordinates.length - 2 : 1), false)), n2(e3));
      };
      var de = { simple_select: oe, direct_select: ae, draw_point: se, draw_polygon: ce, draw_line_string: le }, pe = { defaultMode: j.SIMPLE_SELECT, keybindings: true, touchEnabled: true, clickBuffer: 2, touchBuffer: 25, boxSelect: true, displayControlsDefault: true, styles: [{ id: "gl-draw-polygon-fill-inactive", type: "fill", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], paint: { "fill-color": "#3bb2d0", "fill-outline-color": "#3bb2d0", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-fill-active", type: "fill", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#fbb03b", "fill-outline-color": "#fbb03b", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-midpoint", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-stroke-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "Polygon"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-polygon-stroke-active", type: "line", filter: ["all", ["==", "active", "true"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-line-inactive", type: "line", filter: ["all", ["==", "active", "false"], ["==", "$type", "LineString"], ["!=", "mode", "static"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#3bb2d0", "line-width": 2 } }, { id: "gl-draw-line-active", type: "line", filter: ["all", ["==", "$type", "LineString"], ["==", "active", "true"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#fbb03b", "line-dasharray": [0.2, 2], "line-width": 2 } }, { id: "gl-draw-polygon-and-line-vertex-stroke-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-color": "#fff" } }, { id: "gl-draw-polygon-and-line-vertex-inactive", type: "circle", filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#fbb03b" } }, { id: "gl-draw-point-point-stroke-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 5, "circle-opacity": 1, "circle-color": "#fff" } }, { id: "gl-draw-point-inactive", type: "circle", filter: ["all", ["==", "active", "false"], ["==", "$type", "Point"], ["==", "meta", "feature"], ["!=", "mode", "static"]], paint: { "circle-radius": 3, "circle-color": "#3bb2d0" } }, { id: "gl-draw-point-stroke-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["==", "active", "true"], ["!=", "meta", "midpoint"]], paint: { "circle-radius": 7, "circle-color": "#fff" } }, { id: "gl-draw-point-active", type: "circle", filter: ["all", ["==", "$type", "Point"], ["!=", "meta", "midpoint"], ["==", "active", "true"]], paint: { "circle-radius": 5, "circle-color": "#fbb03b" } }, { id: "gl-draw-polygon-fill-static", type: "fill", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], paint: { "fill-color": "#404040", "fill-outline-color": "#404040", "fill-opacity": 0.1 } }, { id: "gl-draw-polygon-stroke-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Polygon"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-line-static", type: "line", filter: ["all", ["==", "mode", "static"], ["==", "$type", "LineString"]], layout: { "line-cap": "round", "line-join": "round" }, paint: { "line-color": "#404040", "line-width": 2 } }, { id: "gl-draw-point-static", type: "circle", filter: ["all", ["==", "mode", "static"], ["==", "$type", "Point"]], paint: { "circle-radius": 5, "circle-color": "#404040" } }], modes: de, controls: {}, userProperties: false }, fe = { point: true, line_string: true, polygon: true, trash: true, combine_features: true, uncombine_features: true }, he = { point: false, line_string: false, polygon: false, trash: false, combine_features: false, uncombine_features: false };
      function ge(t2, e3) {
        return t2.map(function(t3) {
          return t3.source ? t3 : Mt(t3, { id: t3.id + "." + e3, source: "hot" === e3 ? v : m });
        });
      }
      var ye = ut(function(t2, e3) {
        var n2 = "[object Arguments]", o2 = "[object Map]", r2 = "[object Object]", i2 = "[object Set]", a2 = /^\[object .+?Constructor\]$/, s2 = /^(?:0|[1-9]\d*)$/, u2 = {};
        u2["[object Float32Array]"] = u2["[object Float64Array]"] = u2["[object Int8Array]"] = u2["[object Int16Array]"] = u2["[object Int32Array]"] = u2["[object Uint8Array]"] = u2["[object Uint8ClampedArray]"] = u2["[object Uint16Array]"] = u2["[object Uint32Array]"] = true, u2[n2] = u2["[object Array]"] = u2["[object ArrayBuffer]"] = u2["[object Boolean]"] = u2["[object DataView]"] = u2["[object Date]"] = u2["[object Error]"] = u2["[object Function]"] = u2[o2] = u2["[object Number]"] = u2[r2] = u2["[object RegExp]"] = u2[i2] = u2["[object String]"] = u2["[object WeakMap]"] = false;
        var c2 = "object" == typeof global && global && global.Object === Object && global, l2 = "object" == typeof self && self && self.Object === Object && self, d2 = c2 || l2 || Function("return this")(), p2 = e3 && !e3.nodeType && e3, f2 = p2 && t2 && !t2.nodeType && t2, h2 = f2 && f2.exports === p2, g2 = h2 && c2.process, y2 = function() {
          try {
            return g2 && g2.binding && g2.binding("util");
          } catch (t3) {
          }
        }(), v2 = y2 && y2.isTypedArray;
        function m2(t3, e4) {
          for (var n3 = -1, o3 = null == t3 ? 0 : t3.length; ++n3 < o3; )
            if (e4(t3[n3], n3, t3))
              return true;
          return false;
        }
        function b2(t3) {
          var e4 = -1, n3 = Array(t3.size);
          return t3.forEach(function(t4, o3) {
            n3[++e4] = [o3, t4];
          }), n3;
        }
        function _2(t3) {
          var e4 = -1, n3 = Array(t3.size);
          return t3.forEach(function(t4) {
            n3[++e4] = t4;
          }), n3;
        }
        var S2, x2, C2, E2 = Array.prototype, M2 = Function.prototype, w2 = Object.prototype, I2 = d2["__core-js_shared__"], L2 = M2.toString, P2 = w2.hasOwnProperty, F2 = (S2 = /[^.]+$/.exec(I2 && I2.keys && I2.keys.IE_PROTO || "")) ? "Symbol(src)_1." + S2 : "", O2 = w2.toString, k2 = RegExp("^" + L2.call(P2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), T2 = h2 ? d2.Buffer : void 0, j2 = d2.Symbol, A2 = d2.Uint8Array, D2 = w2.propertyIsEnumerable, N2 = E2.splice, U2 = j2 ? j2.toStringTag : void 0, R2 = Object.getOwnPropertySymbols, B2 = T2 ? T2.isBuffer : void 0, V2 = (x2 = Object.keys, C2 = Object, function(t3) {
          return x2(C2(t3));
        }), J2 = yt2(d2, "DataView"), G2 = yt2(d2, "Map"), z2 = yt2(d2, "Promise"), $2 = yt2(d2, "Set"), W2 = yt2(d2, "WeakMap"), q2 = yt2(Object, "create"), Y2 = _t2(J2), Z2 = _t2(G2), K2 = _t2(z2), X2 = _t2($2), H2 = _t2(W2), Q2 = j2 ? j2.prototype : void 0, tt2 = Q2 ? Q2.valueOf : void 0;
        function et2(t3) {
          var e4 = -1, n3 = null == t3 ? 0 : t3.length;
          for (this.clear(); ++e4 < n3; ) {
            var o3 = t3[e4];
            this.set(o3[0], o3[1]);
          }
        }
        function nt2(t3) {
          var e4 = -1, n3 = null == t3 ? 0 : t3.length;
          for (this.clear(); ++e4 < n3; ) {
            var o3 = t3[e4];
            this.set(o3[0], o3[1]);
          }
        }
        function ot2(t3) {
          var e4 = -1, n3 = null == t3 ? 0 : t3.length;
          for (this.clear(); ++e4 < n3; ) {
            var o3 = t3[e4];
            this.set(o3[0], o3[1]);
          }
        }
        function rt2(t3) {
          var e4 = -1, n3 = null == t3 ? 0 : t3.length;
          for (this.__data__ = new ot2(); ++e4 < n3; )
            this.add(t3[e4]);
        }
        function it2(t3) {
          var e4 = this.__data__ = new nt2(t3);
          this.size = e4.size;
        }
        function at2(t3, e4) {
          var n3 = Ct2(t3), o3 = !n3 && xt2(t3), r3 = !n3 && !o3 && Et2(t3), i3 = !n3 && !o3 && !r3 && Pt2(t3), a3 = n3 || o3 || r3 || i3, s3 = a3 ? function(t4, e5) {
            for (var n4 = -1, o4 = Array(t4); ++n4 < t4; )
              o4[n4] = e5(n4);
            return o4;
          }(t3.length, String) : [], u3 = s3.length;
          for (var c3 in t3)
            !e4 && !P2.call(t3, c3) || a3 && ("length" == c3 || r3 && ("offset" == c3 || "parent" == c3) || i3 && ("buffer" == c3 || "byteLength" == c3 || "byteOffset" == c3) || bt2(c3, u3)) || s3.push(c3);
          return s3;
        }
        function st2(t3, e4) {
          for (var n3 = t3.length; n3--; )
            if (St2(t3[n3][0], e4))
              return n3;
          return -1;
        }
        function ut2(t3) {
          return null == t3 ? void 0 === t3 ? "[object Undefined]" : "[object Null]" : U2 && U2 in Object(t3) ? function(t4) {
            var e4 = P2.call(t4, U2), n3 = t4[U2];
            try {
              t4[U2] = void 0;
              var o3 = true;
            } catch (t5) {
            }
            var r3 = O2.call(t4);
            o3 && (e4 ? t4[U2] = n3 : delete t4[U2]);
            return r3;
          }(t3) : function(t4) {
            return O2.call(t4);
          }(t3);
        }
        function ct2(t3) {
          return Lt2(t3) && ut2(t3) == n2;
        }
        function lt2(t3, e4, a3, s3, u3) {
          return t3 === e4 || (null == t3 || null == e4 || !Lt2(t3) && !Lt2(e4) ? t3 != t3 && e4 != e4 : function(t4, e5, a4, s4, u4, c3) {
            var l3 = Ct2(t4), d3 = Ct2(e5), p3 = l3 ? "[object Array]" : mt2(t4), f3 = d3 ? "[object Array]" : mt2(e5), h3 = (p3 = p3 == n2 ? r2 : p3) == r2, g3 = (f3 = f3 == n2 ? r2 : f3) == r2, y3 = p3 == f3;
            if (y3 && Et2(t4)) {
              if (!Et2(e5))
                return false;
              l3 = true, h3 = false;
            }
            if (y3 && !h3)
              return c3 || (c3 = new it2()), l3 || Pt2(t4) ? ft2(t4, e5, a4, s4, u4, c3) : function(t5, e6, n3, r3, a5, s5, u5) {
                switch (n3) {
                  case "[object DataView]":
                    if (t5.byteLength != e6.byteLength || t5.byteOffset != e6.byteOffset)
                      return false;
                    t5 = t5.buffer, e6 = e6.buffer;
                  case "[object ArrayBuffer]":
                    return !(t5.byteLength != e6.byteLength || !s5(new A2(t5), new A2(e6)));
                  case "[object Boolean]":
                  case "[object Date]":
                  case "[object Number]":
                    return St2(+t5, +e6);
                  case "[object Error]":
                    return t5.name == e6.name && t5.message == e6.message;
                  case "[object RegExp]":
                  case "[object String]":
                    return t5 == e6 + "";
                  case o2:
                    var c4 = b2;
                  case i2:
                    var l4 = 1 & r3;
                    if (c4 || (c4 = _2), t5.size != e6.size && !l4)
                      return false;
                    var d4 = u5.get(t5);
                    if (d4)
                      return d4 == e6;
                    r3 |= 2, u5.set(t5, e6);
                    var p4 = ft2(c4(t5), c4(e6), r3, a5, s5, u5);
                    return u5.delete(t5), p4;
                  case "[object Symbol]":
                    if (tt2)
                      return tt2.call(t5) == tt2.call(e6);
                }
                return false;
              }(t4, e5, p3, a4, s4, u4, c3);
            if (!(1 & a4)) {
              var v3 = h3 && P2.call(t4, "__wrapped__"), m3 = g3 && P2.call(e5, "__wrapped__");
              if (v3 || m3) {
                var S3 = v3 ? t4.value() : t4, x3 = m3 ? e5.value() : e5;
                return c3 || (c3 = new it2()), u4(S3, x3, a4, s4, c3);
              }
            }
            if (!y3)
              return false;
            return c3 || (c3 = new it2()), function(t5, e6, n3, o3, r3, i3) {
              var a5 = 1 & n3, s5 = ht2(t5), u5 = s5.length, c4 = ht2(e6).length;
              if (u5 != c4 && !a5)
                return false;
              var l4 = u5;
              for (; l4--; ) {
                var d4 = s5[l4];
                if (!(a5 ? d4 in e6 : P2.call(e6, d4)))
                  return false;
              }
              var p4 = i3.get(t5);
              if (p4 && i3.get(e6))
                return p4 == e6;
              var f4 = true;
              i3.set(t5, e6), i3.set(e6, t5);
              var h4 = a5;
              for (; ++l4 < u5; ) {
                d4 = s5[l4];
                var g4 = t5[d4], y4 = e6[d4];
                if (o3)
                  var v4 = a5 ? o3(y4, g4, d4, e6, t5, i3) : o3(g4, y4, d4, t5, e6, i3);
                if (!(void 0 === v4 ? g4 === y4 || r3(g4, y4, n3, o3, i3) : v4)) {
                  f4 = false;
                  break;
                }
                h4 || (h4 = "constructor" == d4);
              }
              if (f4 && !h4) {
                var m4 = t5.constructor, b3 = e6.constructor;
                m4 == b3 || !("constructor" in t5) || !("constructor" in e6) || "function" == typeof m4 && m4 instanceof m4 && "function" == typeof b3 && b3 instanceof b3 || (f4 = false);
              }
              return i3.delete(t5), i3.delete(e6), f4;
            }(t4, e5, a4, s4, u4, c3);
          }(t3, e4, a3, s3, lt2, u3));
        }
        function dt2(t3) {
          return !(!It2(t3) || function(t4) {
            return !!F2 && F2 in t4;
          }(t3)) && (Mt2(t3) ? k2 : a2).test(_t2(t3));
        }
        function pt2(t3) {
          if (n3 = (e4 = t3) && e4.constructor, o3 = "function" == typeof n3 && n3.prototype || w2, e4 !== o3)
            return V2(t3);
          var e4, n3, o3, r3 = [];
          for (var i3 in Object(t3))
            P2.call(t3, i3) && "constructor" != i3 && r3.push(i3);
          return r3;
        }
        function ft2(t3, e4, n3, o3, r3, i3) {
          var a3 = 1 & n3, s3 = t3.length, u3 = e4.length;
          if (s3 != u3 && !(a3 && u3 > s3))
            return false;
          var c3 = i3.get(t3);
          if (c3 && i3.get(e4))
            return c3 == e4;
          var l3 = -1, d3 = true, p3 = 2 & n3 ? new rt2() : void 0;
          for (i3.set(t3, e4), i3.set(e4, t3); ++l3 < s3; ) {
            var f3 = t3[l3], h3 = e4[l3];
            if (o3)
              var g3 = a3 ? o3(h3, f3, l3, e4, t3, i3) : o3(f3, h3, l3, t3, e4, i3);
            if (void 0 !== g3) {
              if (g3)
                continue;
              d3 = false;
              break;
            }
            if (p3) {
              if (!m2(e4, function(t4, e5) {
                if (a4 = e5, !p3.has(a4) && (f3 === t4 || r3(f3, t4, n3, o3, i3)))
                  return p3.push(e5);
                var a4;
              })) {
                d3 = false;
                break;
              }
            } else if (f3 !== h3 && !r3(f3, h3, n3, o3, i3)) {
              d3 = false;
              break;
            }
          }
          return i3.delete(t3), i3.delete(e4), d3;
        }
        function ht2(t3) {
          return function(t4, e4, n3) {
            var o3 = e4(t4);
            return Ct2(t4) ? o3 : function(t5, e5) {
              for (var n4 = -1, o4 = e5.length, r3 = t5.length; ++n4 < o4; )
                t5[r3 + n4] = e5[n4];
              return t5;
            }(o3, n3(t4));
          }(t3, Ft2, vt2);
        }
        function gt2(t3, e4) {
          var n3, o3, r3 = t3.__data__;
          return ("string" == (o3 = typeof (n3 = e4)) || "number" == o3 || "symbol" == o3 || "boolean" == o3 ? "__proto__" !== n3 : null === n3) ? r3["string" == typeof e4 ? "string" : "hash"] : r3.map;
        }
        function yt2(t3, e4) {
          var n3 = function(t4, e5) {
            return null == t4 ? void 0 : t4[e5];
          }(t3, e4);
          return dt2(n3) ? n3 : void 0;
        }
        et2.prototype.clear = function() {
          this.__data__ = q2 ? q2(null) : {}, this.size = 0;
        }, et2.prototype.delete = function(t3) {
          var e4 = this.has(t3) && delete this.__data__[t3];
          return this.size -= e4 ? 1 : 0, e4;
        }, et2.prototype.get = function(t3) {
          var e4 = this.__data__;
          if (q2) {
            var n3 = e4[t3];
            return "__lodash_hash_undefined__" === n3 ? void 0 : n3;
          }
          return P2.call(e4, t3) ? e4[t3] : void 0;
        }, et2.prototype.has = function(t3) {
          var e4 = this.__data__;
          return q2 ? void 0 !== e4[t3] : P2.call(e4, t3);
        }, et2.prototype.set = function(t3, e4) {
          var n3 = this.__data__;
          return this.size += this.has(t3) ? 0 : 1, n3[t3] = q2 && void 0 === e4 ? "__lodash_hash_undefined__" : e4, this;
        }, nt2.prototype.clear = function() {
          this.__data__ = [], this.size = 0;
        }, nt2.prototype.delete = function(t3) {
          var e4 = this.__data__, n3 = st2(e4, t3);
          return !(n3 < 0) && (n3 == e4.length - 1 ? e4.pop() : N2.call(e4, n3, 1), --this.size, true);
        }, nt2.prototype.get = function(t3) {
          var e4 = this.__data__, n3 = st2(e4, t3);
          return n3 < 0 ? void 0 : e4[n3][1];
        }, nt2.prototype.has = function(t3) {
          return st2(this.__data__, t3) > -1;
        }, nt2.prototype.set = function(t3, e4) {
          var n3 = this.__data__, o3 = st2(n3, t3);
          return o3 < 0 ? (++this.size, n3.push([t3, e4])) : n3[o3][1] = e4, this;
        }, ot2.prototype.clear = function() {
          this.size = 0, this.__data__ = { hash: new et2(), map: new (G2 || nt2)(), string: new et2() };
        }, ot2.prototype.delete = function(t3) {
          var e4 = gt2(this, t3).delete(t3);
          return this.size -= e4 ? 1 : 0, e4;
        }, ot2.prototype.get = function(t3) {
          return gt2(this, t3).get(t3);
        }, ot2.prototype.has = function(t3) {
          return gt2(this, t3).has(t3);
        }, ot2.prototype.set = function(t3, e4) {
          var n3 = gt2(this, t3), o3 = n3.size;
          return n3.set(t3, e4), this.size += n3.size == o3 ? 0 : 1, this;
        }, rt2.prototype.add = rt2.prototype.push = function(t3) {
          return this.__data__.set(t3, "__lodash_hash_undefined__"), this;
        }, rt2.prototype.has = function(t3) {
          return this.__data__.has(t3);
        }, it2.prototype.clear = function() {
          this.__data__ = new nt2(), this.size = 0;
        }, it2.prototype.delete = function(t3) {
          var e4 = this.__data__, n3 = e4.delete(t3);
          return this.size = e4.size, n3;
        }, it2.prototype.get = function(t3) {
          return this.__data__.get(t3);
        }, it2.prototype.has = function(t3) {
          return this.__data__.has(t3);
        }, it2.prototype.set = function(t3, e4) {
          var n3 = this.__data__;
          if (n3 instanceof nt2) {
            var o3 = n3.__data__;
            if (!G2 || o3.length < 199)
              return o3.push([t3, e4]), this.size = ++n3.size, this;
            n3 = this.__data__ = new ot2(o3);
          }
          return n3.set(t3, e4), this.size = n3.size, this;
        };
        var vt2 = R2 ? function(t3) {
          return null == t3 ? [] : (t3 = Object(t3), function(t4, e4) {
            for (var n3 = -1, o3 = null == t4 ? 0 : t4.length, r3 = 0, i3 = []; ++n3 < o3; ) {
              var a3 = t4[n3];
              e4(a3, n3, t4) && (i3[r3++] = a3);
            }
            return i3;
          }(R2(t3), function(e4) {
            return D2.call(t3, e4);
          }));
        } : function() {
          return [];
        }, mt2 = ut2;
        function bt2(t3, e4) {
          return !!(e4 = null == e4 ? 9007199254740991 : e4) && ("number" == typeof t3 || s2.test(t3)) && t3 > -1 && t3 % 1 == 0 && t3 < e4;
        }
        function _t2(t3) {
          if (null != t3) {
            try {
              return L2.call(t3);
            } catch (t4) {
            }
            try {
              return t3 + "";
            } catch (t4) {
            }
          }
          return "";
        }
        function St2(t3, e4) {
          return t3 === e4 || t3 != t3 && e4 != e4;
        }
        (J2 && "[object DataView]" != mt2(new J2(new ArrayBuffer(1))) || G2 && mt2(new G2()) != o2 || z2 && "[object Promise]" != mt2(z2.resolve()) || $2 && mt2(new $2()) != i2 || W2 && "[object WeakMap]" != mt2(new W2())) && (mt2 = function(t3) {
          var e4 = ut2(t3), n3 = e4 == r2 ? t3.constructor : void 0, a3 = n3 ? _t2(n3) : "";
          if (a3)
            switch (a3) {
              case Y2:
                return "[object DataView]";
              case Z2:
                return o2;
              case K2:
                return "[object Promise]";
              case X2:
                return i2;
              case H2:
                return "[object WeakMap]";
            }
          return e4;
        });
        var xt2 = ct2(function() {
          return arguments;
        }()) ? ct2 : function(t3) {
          return Lt2(t3) && P2.call(t3, "callee") && !D2.call(t3, "callee");
        }, Ct2 = Array.isArray;
        var Et2 = B2 || function() {
          return false;
        };
        function Mt2(t3) {
          if (!It2(t3))
            return false;
          var e4 = ut2(t3);
          return "[object Function]" == e4 || "[object GeneratorFunction]" == e4 || "[object AsyncFunction]" == e4 || "[object Proxy]" == e4;
        }
        function wt2(t3) {
          return "number" == typeof t3 && t3 > -1 && t3 % 1 == 0 && t3 <= 9007199254740991;
        }
        function It2(t3) {
          var e4 = typeof t3;
          return null != t3 && ("object" == e4 || "function" == e4);
        }
        function Lt2(t3) {
          return null != t3 && "object" == typeof t3;
        }
        var Pt2 = v2 ? function(t3) {
          return function(e4) {
            return t3(e4);
          };
        }(v2) : function(t3) {
          return Lt2(t3) && wt2(t3.length) && !!u2[ut2(t3)];
        };
        function Ft2(t3) {
          return null != (e4 = t3) && wt2(e4.length) && !Mt2(e4) ? at2(t3) : pt2(t3);
          var e4;
        }
        t2.exports = function(t3, e4) {
          return lt2(t3, e4);
        };
      });
      var ve = { Polygon: ft, LineString: pt, Point: dt, MultiPolygon: yt, MultiLineString: yt, MultiPoint: yt };
      function me(t2, e3) {
        return e3.modes = j, e3.getFeatureIdsAt = function(e4) {
          return nt.click({ point: e4 }, null, t2).map(function(t3) {
            return t3.properties.id;
          });
        }, e3.getSelectedIds = function() {
          return t2.store.getSelectedIds();
        }, e3.getSelected = function() {
          return { type: P, features: t2.store.getSelectedIds().map(function(e4) {
            return t2.store.get(e4);
          }).map(function(t3) {
            return t3.toGeoJSON();
          }) };
        }, e3.getSelectedPoints = function() {
          return { type: P, features: t2.store.getSelectedCoordinates().map(function(t3) {
            return { type: M, properties: {}, geometry: { type: L, coordinates: t3.coordinates } };
          }) };
        }, e3.set = function(n2) {
          if (void 0 === n2.type || n2.type !== P || !Array.isArray(n2.features))
            throw new Error("Invalid FeatureCollection");
          var o2 = t2.store.createRenderBatch(), r2 = t2.store.getAllIds().slice(), i2 = e3.add(n2), a2 = new tt(i2);
          return (r2 = r2.filter(function(t3) {
            return !a2.has(t3);
          })).length && e3.delete(r2), o2(), i2;
        }, e3.add = function(e4) {
          var n2 = JSON.parse(JSON.stringify(zt(e4))).features.map(function(e5) {
            if (e5.id = e5.id || ct(), null === e5.geometry)
              throw new Error("Invalid geometry: null");
            if (void 0 === t2.store.get(e5.id) || t2.store.get(e5.id).type !== e5.geometry.type) {
              var n3 = ve[e5.geometry.type];
              if (void 0 === n3)
                throw new Error("Invalid geometry type: " + e5.geometry.type + ".");
              var o2 = new n3(t2, e5);
              t2.store.add(o2);
            } else {
              var r2 = t2.store.get(e5.id);
              r2.properties = e5.properties, ye(r2.getCoordinates(), e5.geometry.coordinates) || r2.incomingCoords(e5.geometry.coordinates);
            }
            return e5.id;
          });
          return t2.store.render(), n2;
        }, e3.get = function(e4) {
          var n2 = t2.store.get(e4);
          if (n2)
            return n2.toGeoJSON();
        }, e3.getAll = function() {
          return { type: P, features: t2.store.getAll().map(function(t3) {
            return t3.toGeoJSON();
          }) };
        }, e3.delete = function(n2) {
          return t2.store.delete(n2, { silent: true }), e3.getMode() !== j.DIRECT_SELECT || t2.store.getSelectedIds().length ? t2.store.render() : t2.events.changeMode(j.SIMPLE_SELECT, void 0, { silent: true }), e3;
        }, e3.deleteAll = function() {
          return t2.store.delete(t2.store.getAllIds(), { silent: true }), e3.getMode() === j.DIRECT_SELECT ? t2.events.changeMode(j.SIMPLE_SELECT, void 0, { silent: true }) : t2.store.render(), e3;
        }, e3.changeMode = function(n2, o2) {
          return void 0 === o2 && (o2 = {}), n2 === j.SIMPLE_SELECT && e3.getMode() === j.SIMPLE_SELECT ? (r2 = o2.featureIds || [], i2 = t2.store.getSelectedIds(), r2.length === i2.length && JSON.stringify(r2.map(function(t3) {
            return t3;
          }).sort()) === JSON.stringify(i2.map(function(t3) {
            return t3;
          }).sort()) || (t2.store.setSelected(o2.featureIds, { silent: true }), t2.store.render()), e3) : (n2 === j.DIRECT_SELECT && e3.getMode() === j.DIRECT_SELECT && o2.featureId === t2.store.getSelectedIds()[0] || t2.events.changeMode(n2, o2, { silent: true }), e3);
          var r2, i2;
        }, e3.getMode = function() {
          return t2.events.getMode();
        }, e3.trash = function() {
          return t2.events.trash({ silent: true }), e3;
        }, e3.combineFeatures = function() {
          return t2.events.combineFeatures({ silent: true }), e3;
        }, e3.uncombineFeatures = function() {
          return t2.events.uncombineFeatures({ silent: true }), e3;
        }, e3.setFeatureProperty = function(n2, o2, r2) {
          return t2.store.setFeatureProperty(n2, o2, r2), e3;
        }, e3;
      }
      var be = function(t2, e3) {
        var n2 = { options: t2 = function(t3) {
          void 0 === t3 && (t3 = {});
          var e4 = Mt(t3);
          return t3.controls || (e4.controls = {}), false === t3.displayControlsDefault ? e4.controls = Mt(he, t3.controls) : e4.controls = Mt(fe, t3.controls), (e4 = Mt(pe, e4)).styles = ge(e4.styles, "cold").concat(ge(e4.styles, "hot")), e4;
        }(t2) };
        e3 = me(n2, e3), n2.api = e3;
        var o2 = Lt(n2);
        return e3.onAdd = o2.onAdd, e3.onRemove = o2.onRemove, e3.types = E, e3.options = t2, e3;
      };
      function _e(t2) {
        be(t2, this);
      }
      return _e.modes = de, _e;
    });
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/constants.js
var require_constants = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/constants.js"(exports, module) {
    module.exports = {
      classes: {
        CONTROL_BASE: "mapboxgl-ctrl",
        CONTROL_PREFIX: "mapboxgl-ctrl-",
        CONTROL_BUTTON: "mapbox-gl-draw_ctrl-draw-btn",
        CONTROL_BUTTON_LINE: "mapbox-gl-draw_line",
        CONTROL_BUTTON_POLYGON: "mapbox-gl-draw_polygon",
        CONTROL_BUTTON_POINT: "mapbox-gl-draw_point",
        CONTROL_BUTTON_TRASH: "mapbox-gl-draw_trash",
        CONTROL_BUTTON_COMBINE_FEATURES: "mapbox-gl-draw_combine",
        CONTROL_BUTTON_UNCOMBINE_FEATURES: "mapbox-gl-draw_uncombine",
        CONTROL_GROUP: "mapboxgl-ctrl-group",
        ATTRIBUTION: "mapboxgl-ctrl-attrib",
        ACTIVE_BUTTON: "active",
        BOX_SELECT: "mapbox-gl-draw_boxselect"
      },
      sources: {
        HOT: "mapbox-gl-draw-hot",
        COLD: "mapbox-gl-draw-cold"
      },
      cursors: {
        ADD: "add",
        MOVE: "move",
        DRAG: "drag",
        POINTER: "pointer",
        NONE: "none"
      },
      types: {
        POLYGON: "polygon",
        LINE: "line_string",
        POINT: "point"
      },
      geojsonTypes: {
        FEATURE: "Feature",
        POLYGON: "Polygon",
        LINE_STRING: "LineString",
        POINT: "Point",
        FEATURE_COLLECTION: "FeatureCollection",
        MULTI_PREFIX: "Multi",
        MULTI_POINT: "MultiPoint",
        MULTI_LINE_STRING: "MultiLineString",
        MULTI_POLYGON: "MultiPolygon"
      },
      modes: {
        DRAW_LINE_STRING: "draw_line_string",
        DRAW_POLYGON: "draw_polygon",
        DRAW_POINT: "draw_point",
        SIMPLE_SELECT: "simple_select",
        DIRECT_SELECT: "direct_select",
        STATIC: "static"
      },
      events: {
        CREATE: "draw.create",
        DELETE: "draw.delete",
        UPDATE: "draw.update",
        SELECTION_CHANGE: "draw.selectionchange",
        MODE_CHANGE: "draw.modechange",
        ACTIONABLE: "draw.actionable",
        RENDER: "draw.render",
        COMBINE_FEATURES: "draw.combine",
        UNCOMBINE_FEATURES: "draw.uncombine"
      },
      updateActions: {
        MOVE: "move",
        CHANGE_COORDINATES: "change_coordinates"
      },
      meta: {
        FEATURE: "feature",
        MIDPOINT: "midpoint",
        VERTEX: "vertex"
      },
      activeStates: {
        ACTIVE: "true",
        INACTIVE: "false"
      },
      interactions: ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"],
      LAT_MIN: -90,
      LAT_RENDERED_MIN: -85,
      LAT_MAX: 90,
      LAT_RENDERED_MAX: 85,
      LNG_MIN: -270,
      LNG_MAX: 270
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/double_click_zoom.js
var require_double_click_zoom = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/double_click_zoom.js"(exports, module) {
    module.exports = {
      enable(ctx) {
        setTimeout(() => {
          if (!ctx.map || !ctx.map.doubleClickZoom || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue)
            return;
          if (!ctx._ctx.store.getInitialConfigValue("doubleClickZoom"))
            return;
          ctx.map.doubleClickZoom.enable();
        }, 0);
      },
      disable(ctx) {
        setTimeout(() => {
          if (!ctx.map || !ctx.map.doubleClickZoom)
            return;
          ctx.map.doubleClickZoom.disable();
        }, 0);
      }
    };
  }
});

// node_modules/@turf/helpers/dist/js/index.js
var require_js = __commonJS({
  "node_modules/@turf/helpers/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.earthRadius = 63710088e-1;
    exports.factors = {
      centimeters: exports.earthRadius * 100,
      centimetres: exports.earthRadius * 100,
      degrees: exports.earthRadius / 111325,
      feet: exports.earthRadius * 3.28084,
      inches: exports.earthRadius * 39.37,
      kilometers: exports.earthRadius / 1e3,
      kilometres: exports.earthRadius / 1e3,
      meters: exports.earthRadius,
      metres: exports.earthRadius,
      miles: exports.earthRadius / 1609.344,
      millimeters: exports.earthRadius * 1e3,
      millimetres: exports.earthRadius * 1e3,
      nauticalmiles: exports.earthRadius / 1852,
      radians: 1,
      yards: exports.earthRadius * 1.0936
    };
    exports.unitsFactors = {
      centimeters: 100,
      centimetres: 100,
      degrees: 1 / 111325,
      feet: 3.28084,
      inches: 39.37,
      kilometers: 1 / 1e3,
      kilometres: 1 / 1e3,
      meters: 1,
      metres: 1,
      miles: 1 / 1609.344,
      millimeters: 1e3,
      millimetres: 1e3,
      nauticalmiles: 1 / 1852,
      radians: 1 / exports.earthRadius,
      yards: 1.0936133
    };
    exports.areaFactors = {
      acres: 247105e-9,
      centimeters: 1e4,
      centimetres: 1e4,
      feet: 10.763910417,
      hectares: 1e-4,
      inches: 1550.003100006,
      kilometers: 1e-6,
      kilometres: 1e-6,
      meters: 1,
      metres: 1,
      miles: 386e-9,
      millimeters: 1e6,
      millimetres: 1e6,
      yards: 1.195990046
    };
    function feature2(geom, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var feat = { type: "Feature" };
      if (options.id === 0 || options.id) {
        feat.id = options.id;
      }
      if (options.bbox) {
        feat.bbox = options.bbox;
      }
      feat.properties = properties || {};
      feat.geometry = geom;
      return feat;
    }
    exports.feature = feature2;
    function geometry(type, coordinates, _options) {
      if (_options === void 0) {
        _options = {};
      }
      switch (type) {
        case "Point":
          return point2(coordinates).geometry;
        case "LineString":
          return lineString2(coordinates).geometry;
        case "Polygon":
          return polygon2(coordinates).geometry;
        case "MultiPoint":
          return multiPoint(coordinates).geometry;
        case "MultiLineString":
          return multiLineString(coordinates).geometry;
        case "MultiPolygon":
          return multiPolygon(coordinates).geometry;
        default:
          throw new Error(type + " is invalid");
      }
    }
    exports.geometry = geometry;
    function point2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      if (!coordinates) {
        throw new Error("coordinates is required");
      }
      if (!Array.isArray(coordinates)) {
        throw new Error("coordinates must be an Array");
      }
      if (coordinates.length < 2) {
        throw new Error("coordinates must be at least 2 numbers long");
      }
      if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
        throw new Error("coordinates must contain numbers");
      }
      var geom = {
        type: "Point",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.point = point2;
    function points(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection(coordinates.map(function(coords) {
        return point2(coords, properties);
      }), options);
    }
    exports.points = points;
    function polygon2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
          throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
          if (ring[ring.length - 1][j] !== ring[0][j]) {
            throw new Error("First and last Position are not equivalent.");
          }
        }
      }
      var geom = {
        type: "Polygon",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.polygon = polygon2;
    function polygons(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection(coordinates.map(function(coords) {
        return polygon2(coords, properties);
      }), options);
    }
    exports.polygons = polygons;
    function lineString2(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
      }
      var geom = {
        type: "LineString",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.lineString = lineString2;
    function lineStrings(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      return featureCollection(coordinates.map(function(coords) {
        return lineString2(coords, properties);
      }), options);
    }
    exports.lineStrings = lineStrings;
    function featureCollection(features, options) {
      if (options === void 0) {
        options = {};
      }
      var fc = { type: "FeatureCollection" };
      if (options.id) {
        fc.id = options.id;
      }
      if (options.bbox) {
        fc.bbox = options.bbox;
      }
      fc.features = features;
      return fc;
    }
    exports.featureCollection = featureCollection;
    function multiLineString(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiLineString",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.multiLineString = multiLineString;
    function multiPoint(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiPoint",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.multiPoint = multiPoint;
    function multiPolygon(coordinates, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "MultiPolygon",
        coordinates
      };
      return feature2(geom, properties, options);
    }
    exports.multiPolygon = multiPolygon;
    function geometryCollection(geometries, properties, options) {
      if (options === void 0) {
        options = {};
      }
      var geom = {
        type: "GeometryCollection",
        geometries
      };
      return feature2(geom, properties, options);
    }
    exports.geometryCollection = geometryCollection;
    function round(num, precision) {
      if (precision === void 0) {
        precision = 0;
      }
      if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
      }
      var multiplier = Math.pow(10, precision || 0);
      return Math.round(num * multiplier) / multiplier;
    }
    exports.round = round;
    function radiansToLength2(radians, units) {
      if (units === void 0) {
        units = "kilometers";
      }
      var factor = exports.factors[units];
      if (!factor) {
        throw new Error(units + " units is invalid");
      }
      return radians * factor;
    }
    exports.radiansToLength = radiansToLength2;
    function lengthToRadians2(distance2, units) {
      if (units === void 0) {
        units = "kilometers";
      }
      var factor = exports.factors[units];
      if (!factor) {
        throw new Error(units + " units is invalid");
      }
      return distance2 / factor;
    }
    exports.lengthToRadians = lengthToRadians2;
    function lengthToDegrees(distance2, units) {
      return radiansToDegrees2(lengthToRadians2(distance2, units));
    }
    exports.lengthToDegrees = lengthToDegrees;
    function bearingToAzimuth(bearing2) {
      var angle = bearing2 % 360;
      if (angle < 0) {
        angle += 360;
      }
      return angle;
    }
    exports.bearingToAzimuth = bearingToAzimuth;
    function radiansToDegrees2(radians) {
      var degrees = radians % (2 * Math.PI);
      return degrees * 180 / Math.PI;
    }
    exports.radiansToDegrees = radiansToDegrees2;
    function degreesToRadians2(degrees) {
      var radians = degrees % 360;
      return radians * Math.PI / 180;
    }
    exports.degreesToRadians = degreesToRadians2;
    function convertLength(length2, originalUnit, finalUnit) {
      if (originalUnit === void 0) {
        originalUnit = "kilometers";
      }
      if (finalUnit === void 0) {
        finalUnit = "kilometers";
      }
      if (!(length2 >= 0)) {
        throw new Error("length must be a positive number");
      }
      return radiansToLength2(lengthToRadians2(length2, originalUnit), finalUnit);
    }
    exports.convertLength = convertLength;
    function convertArea(area, originalUnit, finalUnit) {
      if (originalUnit === void 0) {
        originalUnit = "meters";
      }
      if (finalUnit === void 0) {
        finalUnit = "kilometers";
      }
      if (!(area >= 0)) {
        throw new Error("area must be a positive number");
      }
      var startFactor = exports.areaFactors[originalUnit];
      if (!startFactor) {
        throw new Error("invalid original units");
      }
      var finalFactor = exports.areaFactors[finalUnit];
      if (!finalFactor) {
        throw new Error("invalid final units");
      }
      return area / startFactor * finalFactor;
    }
    exports.convertArea = convertArea;
    function isNumber(num) {
      return !isNaN(num) && num !== null && !Array.isArray(num);
    }
    exports.isNumber = isNumber;
    function isObject2(input) {
      return !!input && input.constructor === Object;
    }
    exports.isObject = isObject2;
    function validateBBox(bbox) {
      if (!bbox) {
        throw new Error("bbox is required");
      }
      if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
      }
      if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
      }
      bbox.forEach(function(num) {
        if (!isNumber(num)) {
          throw new Error("bbox must only contain numbers");
        }
      });
    }
    exports.validateBBox = validateBBox;
    function validateId(id) {
      if (!id) {
        throw new Error("id is required");
      }
      if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
      }
    }
    exports.validateId = validateId;
  }
});

// node_modules/@turf/invariant/dist/js/index.js
var require_js2 = __commonJS({
  "node_modules/@turf/invariant/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    function getCoord2(coord) {
      if (!coord) {
        throw new Error("coord is required");
      }
      if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
          return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
          return coord.coordinates;
        }
      }
      if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
      }
      throw new Error("coord must be GeoJSON Point or an Array of numbers");
    }
    exports.getCoord = getCoord2;
    function getCoords(coords) {
      if (Array.isArray(coords)) {
        return coords;
      }
      if (coords.type === "Feature") {
        if (coords.geometry !== null) {
          return coords.geometry.coordinates;
        }
      } else {
        if (coords.coordinates) {
          return coords.coordinates;
        }
      }
      throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
    }
    exports.getCoords = getCoords;
    function containsNumber(coordinates) {
      if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
        return true;
      }
      if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
      }
      throw new Error("coordinates must only contain numbers");
    }
    exports.containsNumber = containsNumber;
    function geojsonType(value, type, name) {
      if (!type || !name) {
        throw new Error("type and name required");
      }
      if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
      }
    }
    exports.geojsonType = geojsonType;
    function featureOf(feature2, type, name) {
      if (!feature2) {
        throw new Error("No feature passed");
      }
      if (!name) {
        throw new Error(".featureOf() requires a name");
      }
      if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
      }
      if (!feature2.geometry || feature2.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
      }
    }
    exports.featureOf = featureOf;
    function collectionOf(featureCollection, type, name) {
      if (!featureCollection) {
        throw new Error("No featureCollection passed");
      }
      if (!name) {
        throw new Error(".collectionOf() requires a name");
      }
      if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
      }
      for (var _i = 0, _a2 = featureCollection.features; _i < _a2.length; _i++) {
        var feature2 = _a2[_i];
        if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
          throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature2.geometry || feature2.geometry.type !== type) {
          throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
        }
      }
    }
    exports.collectionOf = collectionOf;
    function getGeom2(geojson) {
      if (geojson.type === "Feature") {
        return geojson.geometry;
      }
      return geojson;
    }
    exports.getGeom = getGeom2;
    function getType(geojson, _name) {
      if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
      }
      if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
      }
      if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
      }
      return geojson.type;
    }
    exports.getType = getType;
  }
});

// node_modules/@turf/destination/dist/js/index.js
var require_js3 = __commonJS({
  "node_modules/@turf/destination/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var helpers_1 = require_js();
    var invariant_1 = require_js2();
    function destination2(origin, distance2, bearing2, options) {
      if (options === void 0) {
        options = {};
      }
      var coordinates1 = invariant_1.getCoord(origin);
      var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);
      var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);
      var bearingRad = helpers_1.degreesToRadians(bearing2);
      var radians = helpers_1.lengthToRadians(distance2, options.units);
      var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
      var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
      var lng = helpers_1.radiansToDegrees(longitude2);
      var lat = helpers_1.radiansToDegrees(latitude2);
      return helpers_1.point([lng, lat], options.properties);
    }
    exports.default = destination2;
  }
});

// node_modules/@turf/circle/dist/js/index.js
var require_js4 = __commonJS({
  "node_modules/@turf/circle/dist/js/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var destination_1 = __importDefault(require_js3());
    var helpers_1 = require_js();
    function circle2(center, radius, options) {
      if (options === void 0) {
        options = {};
      }
      var steps = options.steps || 64;
      var properties = options.properties ? options.properties : !Array.isArray(center) && center.type === "Feature" && center.properties ? center.properties : {};
      var coordinates = [];
      for (var i = 0; i < steps; i++) {
        coordinates.push(destination_1.default(center, radius, i * -360 / steps, options).geometry.coordinates);
      }
      coordinates.push(coordinates[0]);
      return helpers_1.polygon([coordinates], properties);
    }
    exports.default = circle2;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/modes/CircleMode.js
var require_CircleMode = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/modes/CircleMode.js"(exports, module) {
    var MapboxDraw2 = require_mapbox_gl_draw();
    var Constants = require_constants();
    var doubleClickZoom = require_double_click_zoom();
    var circle2 = require_js4().default;
    var CircleMode2 = { ...MapboxDraw2.modes.draw_polygon };
    var DEFAULT_RADIUS_IN_KM = 2;
    CircleMode2.onSetup = function(opts) {
      const polygon2 = this.newFeature({
        type: Constants.geojsonTypes.FEATURE,
        properties: {
          isCircle: true,
          center: []
        },
        geometry: {
          type: Constants.geojsonTypes.POLYGON,
          coordinates: [[]]
        }
      });
      this.addFeature(polygon2);
      this.clearSelectedFeatures();
      doubleClickZoom.disable(this);
      this.updateUIClasses({ mouse: Constants.cursors.ADD });
      this.activateUIButton(Constants.types.POLYGON);
      this.setActionableState({
        trash: true
      });
      return {
        initialRadiusInKm: opts.initialRadiusInKm || DEFAULT_RADIUS_IN_KM,
        polygon: polygon2,
        currentVertexPosition: 0
      };
    };
    CircleMode2.clickAnywhere = function(state, e2) {
      if (state.currentVertexPosition === 0) {
        state.currentVertexPosition++;
        const center = [e2.lngLat.lng, e2.lngLat.lat];
        const circleFeature = circle2(center, state.initialRadiusInKm);
        state.polygon.incomingCoords(circleFeature.geometry.coordinates);
        state.polygon.properties.center = center;
        state.polygon.properties.radiusInKm = state.initialRadiusInKm;
      }
      return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
    };
    module.exports = CircleMode2;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/drag_pan.js
var require_drag_pan = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/drag_pan.js"(exports, module) {
    module.exports = {
      enable(ctx) {
        setTimeout(() => {
          if (!ctx.map || !ctx.map.dragPan || !ctx._ctx || !ctx._ctx.store || !ctx._ctx.store.getInitialConfigValue)
            return;
          if (!ctx._ctx.store.getInitialConfigValue("dragPan"))
            return;
          ctx.map.dragPan.enable();
        }, 0);
      },
      disable(ctx) {
        setTimeout(() => {
          if (!ctx.map || !ctx.map.doubleClickZoom)
            return;
          ctx.map.dragPan.disable();
        }, 0);
      }
    };
  }
});

// node_modules/@turf/distance/dist/js/index.js
var require_js5 = __commonJS({
  "node_modules/@turf/distance/dist/js/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var invariant_1 = require_js2();
    var helpers_1 = require_js();
    function distance2(from, to, options) {
      if (options === void 0) {
        options = {};
      }
      var coordinates1 = invariant_1.getCoord(from);
      var coordinates2 = invariant_1.getCoord(to);
      var dLat = helpers_1.degreesToRadians(coordinates2[1] - coordinates1[1]);
      var dLon = helpers_1.degreesToRadians(coordinates2[0] - coordinates1[0]);
      var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
      var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
      var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
      return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
    }
    exports.default = distance2;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/modes/DragCircleMode.js
var require_DragCircleMode = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/modes/DragCircleMode.js"(exports, module) {
    var MapboxDraw2 = require_mapbox_gl_draw();
    var Constants = require_constants();
    var doubleClickZoom = require_double_click_zoom();
    var dragPan = require_drag_pan();
    var circle2 = require_js4().default;
    var distance2 = require_js5().default;
    var turfHelpers = require_js();
    var DragCircleMode = { ...MapboxDraw2.modes.draw_polygon };
    DragCircleMode.onSetup = function(opts) {
      const polygon2 = this.newFeature({
        type: Constants.geojsonTypes.FEATURE,
        properties: {
          isCircle: true,
          center: []
        },
        geometry: {
          type: Constants.geojsonTypes.POLYGON,
          coordinates: [[]]
        }
      });
      this.addFeature(polygon2);
      this.clearSelectedFeatures();
      doubleClickZoom.disable(this);
      dragPan.disable(this);
      this.updateUIClasses({ mouse: Constants.cursors.ADD });
      this.activateUIButton(Constants.types.POLYGON);
      this.setActionableState({
        trash: true
      });
      return {
        polygon: polygon2,
        currentVertexPosition: 0
      };
    };
    DragCircleMode.onMouseDown = DragCircleMode.onTouchStart = function(state, e2) {
      const currentCenter = state.polygon.properties.center;
      if (currentCenter.length === 0) {
        state.polygon.properties.center = [e2.lngLat.lng, e2.lngLat.lat];
      }
    };
    DragCircleMode.onDrag = DragCircleMode.onMouseMove = function(state, e2) {
      const center = state.polygon.properties.center;
      if (center.length > 0) {
        const distanceInKm = distance2(
          turfHelpers.point(center),
          turfHelpers.point([e2.lngLat.lng, e2.lngLat.lat]),
          { units: "kilometers" }
        );
        const circleFeature = circle2(center, distanceInKm);
        state.polygon.incomingCoords(circleFeature.geometry.coordinates);
        state.polygon.properties.radiusInKm = distanceInKm;
      }
    };
    DragCircleMode.onMouseUp = DragCircleMode.onTouchEnd = function(state, e2) {
      dragPan.enable(this);
      return this.changeMode(Constants.modes.SIMPLE_SELECT, { featureIds: [state.polygon.id] });
    };
    DragCircleMode.onClick = DragCircleMode.onTap = function(state, e2) {
      state.polygon.properties.center = [];
    };
    DragCircleMode.toDisplayFeatures = function(state, geojson, display) {
      const isActivePolygon = geojson.properties.id === state.polygon.id;
      geojson.properties.active = isActivePolygon ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
      return display(geojson);
    };
    module.exports = DragCircleMode;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/create_vertex.js
var require_create_vertex = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/create_vertex.js"(exports, module) {
    var Constants = require_constants();
    module.exports = function(parentId, coordinates, path, selected) {
      return {
        type: Constants.geojsonTypes.FEATURE,
        properties: {
          meta: Constants.meta.VERTEX,
          parent: parentId,
          coord_path: path,
          active: selected ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE
        },
        geometry: {
          type: Constants.geojsonTypes.POINT,
          coordinates
        }
      };
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/create_midpoint.js
var require_create_midpoint = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/create_midpoint.js"(exports, module) {
    var Constants = require_constants();
    module.exports = function(parent, startVertex, endVertex, map) {
      const startCoord = startVertex.geometry.coordinates;
      const endCoord = endVertex.geometry.coordinates;
      if (startCoord[1] > Constants.LAT_RENDERED_MAX || startCoord[1] < Constants.LAT_RENDERED_MIN || endCoord[1] > Constants.LAT_RENDERED_MAX || endCoord[1] < Constants.LAT_RENDERED_MIN) {
        return null;
      }
      const ptA = map.project([startCoord[0], startCoord[1]]);
      const ptB = map.project([endCoord[0], endCoord[1]]);
      const mid = map.unproject([(ptA.x + ptB.x) / 2, (ptA.y + ptB.y) / 2]);
      return {
        type: Constants.geojsonTypes.FEATURE,
        properties: {
          meta: Constants.meta.MIDPOINT,
          parent,
          lng: mid.lng,
          lat: mid.lat,
          coord_path: endVertex.properties.coord_path
        },
        geometry: {
          type: Constants.geojsonTypes.POINT,
          coordinates: [mid.lng, mid.lat]
        }
      };
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/create_supplementary_points.js
var require_create_supplementary_points = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/create_supplementary_points.js"(exports, module) {
    var createVertex = require_create_vertex();
    var createMidpoint = require_create_midpoint();
    var Constants = require_constants();
    function createSupplementaryPoints(geojson, options = {}, basePath = null) {
      const { type, coordinates } = geojson.geometry;
      const featureId = geojson.properties && geojson.properties.id;
      let supplementaryPoints = [];
      if (type === Constants.geojsonTypes.POINT) {
        supplementaryPoints.push(createVertex(featureId, coordinates, basePath, isSelectedPath(basePath)));
      } else if (type === Constants.geojsonTypes.POLYGON) {
        coordinates.forEach((line, lineIndex) => {
          processLine(line, basePath !== null ? `${basePath}.${lineIndex}` : String(lineIndex));
        });
      } else if (type === Constants.geojsonTypes.LINE_STRING) {
        processLine(coordinates, basePath);
      } else if (type.indexOf(Constants.geojsonTypes.MULTI_PREFIX) === 0) {
        processMultiGeometry();
      }
      function processLine(line, lineBasePath) {
        let firstPointString = "";
        let lastVertex = null;
        line.forEach((point2, pointIndex) => {
          const pointPath = lineBasePath !== void 0 && lineBasePath !== null ? `${lineBasePath}.${pointIndex}` : String(pointIndex);
          const vertex = createVertex(featureId, point2, pointPath, isSelectedPath(pointPath));
          if (options.midpoints && lastVertex) {
            const midpoint = createMidpoint(featureId, lastVertex, vertex, options.map);
            if (midpoint) {
              supplementaryPoints.push(midpoint);
            }
          }
          lastVertex = vertex;
          const stringifiedPoint = JSON.stringify(point2);
          if (firstPointString !== stringifiedPoint) {
            supplementaryPoints.push(vertex);
          }
          if (pointIndex === 0) {
            firstPointString = stringifiedPoint;
          }
        });
      }
      function isSelectedPath(path) {
        if (!options.selectedPaths)
          return false;
        return options.selectedPaths.indexOf(path) !== -1;
      }
      function processMultiGeometry() {
        const subType = type.replace(Constants.geojsonTypes.MULTI_PREFIX, "");
        coordinates.forEach((subCoordinates, index) => {
          const subFeature = {
            type: Constants.geojsonTypes.FEATURE,
            properties: geojson.properties,
            geometry: {
              type: subType,
              coordinates: subCoordinates
            }
          };
          supplementaryPoints = supplementaryPoints.concat(createSupplementaryPoints(subFeature, options, index));
        });
      }
      return supplementaryPoints;
    }
    module.exports = createSupplementaryPoints;
  }
});

// node_modules/@mapbox/geojson-normalize/index.js
var require_geojson_normalize = __commonJS({
  "node_modules/@mapbox/geojson-normalize/index.js"(exports, module) {
    module.exports = normalize;
    var types = {
      Point: "geometry",
      MultiPoint: "geometry",
      LineString: "geometry",
      MultiLineString: "geometry",
      Polygon: "geometry",
      MultiPolygon: "geometry",
      GeometryCollection: "geometry",
      Feature: "feature",
      FeatureCollection: "featurecollection"
    };
    function normalize(gj) {
      if (!gj || !gj.type)
        return null;
      var type = types[gj.type];
      if (!type)
        return null;
      if (type === "geometry") {
        return {
          type: "FeatureCollection",
          features: [{
            type: "Feature",
            properties: {},
            geometry: gj
          }]
        };
      } else if (type === "feature") {
        return {
          type: "FeatureCollection",
          features: [gj]
        };
      } else if (type === "featurecollection") {
        return gj;
      }
    }
  }
});

// node_modules/geojson-flatten/dist/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  default: () => e
});
function e(t) {
  switch (t && t.type || null) {
    case "FeatureCollection":
      return t.features = t.features.reduce(function(t2, r) {
        return t2.concat(e(r));
      }, []), t;
    case "Feature":
      return t.geometry ? e(t.geometry).map(function(e2) {
        var r = { type: "Feature", properties: JSON.parse(JSON.stringify(t.properties)), geometry: e2 };
        return void 0 !== t.id && (r.id = t.id), r;
      }) : [t];
    case "MultiPoint":
      return t.coordinates.map(function(e2) {
        return { type: "Point", coordinates: e2 };
      });
    case "MultiPolygon":
      return t.coordinates.map(function(e2) {
        return { type: "Polygon", coordinates: e2 };
      });
    case "MultiLineString":
      return t.coordinates.map(function(e2) {
        return { type: "LineString", coordinates: e2 };
      });
    case "GeometryCollection":
      return t.geometries.map(e).reduce(function(e2, t2) {
        return e2.concat(t2);
      }, []);
    case "Point":
    case "Polygon":
    case "LineString":
      return [t];
  }
}
var init_index_es = __esm({
  "node_modules/geojson-flatten/dist/index.es.js"() {
  }
});

// node_modules/@mapbox/geojson-coords/flatten.js
var require_flatten = __commonJS({
  "node_modules/@mapbox/geojson-coords/flatten.js"(exports, module) {
    module.exports = function flatten(list) {
      return _flatten(list);
      function _flatten(list2) {
        if (Array.isArray(list2) && list2.length && typeof list2[0] === "number") {
          return [list2];
        }
        return list2.reduce(function(acc, item) {
          if (Array.isArray(item) && Array.isArray(item[0])) {
            return acc.concat(_flatten(item));
          } else {
            acc.push(item);
            return acc;
          }
        }, []);
      }
    };
  }
});

// node_modules/@mapbox/geojson-coords/index.js
var require_geojson_coords = __commonJS({
  "node_modules/@mapbox/geojson-coords/index.js"(exports, module) {
    var geojsonNormalize = require_geojson_normalize();
    var geojsonFlatten = (init_index_es(), __toCommonJS(index_es_exports));
    var flatten = require_flatten();
    if (!(geojsonFlatten instanceof Function))
      geojsonFlatten = geojsonFlatten.default;
    module.exports = function(_) {
      if (!_)
        return [];
      var normalized = geojsonFlatten(geojsonNormalize(_)), coordinates = [];
      normalized.features.forEach(function(feature2) {
        if (!feature2.geometry)
          return;
        coordinates = coordinates.concat(flatten(feature2.geometry.coordinates));
      });
      return coordinates;
    };
  }
});

// node_modules/traverse/index.js
var require_traverse = __commonJS({
  "node_modules/traverse/index.js"(exports, module) {
    var traverse = module.exports = function(obj) {
      return new Traverse(obj);
    };
    function Traverse(obj) {
      this.value = obj;
    }
    Traverse.prototype.get = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
          node = void 0;
          break;
        }
        node = node[key];
      }
      return node;
    };
    Traverse.prototype.has = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
          return false;
        }
        node = node[key];
      }
      return true;
    };
    Traverse.prototype.set = function(ps, value) {
      var node = this.value;
      for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key))
          node[key] = {};
        node = node[key];
      }
      node[ps[i]] = value;
      return value;
    };
    Traverse.prototype.map = function(cb) {
      return walk(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
      this.value = walk(this.value, cb, false);
      return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
      var skip = arguments.length === 1;
      var acc = skip ? this.value : init;
      this.forEach(function(x) {
        if (!this.isRoot || !skip) {
          acc = cb.call(this, acc, x);
        }
      });
      return acc;
    };
    Traverse.prototype.paths = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.path);
      });
      return acc;
    };
    Traverse.prototype.nodes = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.node);
      });
      return acc;
    };
    Traverse.prototype.clone = function() {
      var parents = [], nodes = [];
      return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
          if (parents[i] === src) {
            return nodes[i];
          }
        }
        if (typeof src === "object" && src !== null) {
          var dst = copy(src);
          parents.push(src);
          nodes.push(dst);
          forEach(objectKeys(src), function(key) {
            dst[key] = clone(src[key]);
          });
          parents.pop();
          nodes.pop();
          return dst;
        } else {
          return src;
        }
      }(this.value);
    };
    function walk(root, cb, immutable) {
      var path = [];
      var parents = [];
      var alive = true;
      return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var keepGoing = true;
        var state = {
          node,
          node_,
          path: [].concat(path),
          parent: parents[parents.length - 1],
          parents,
          key: path.slice(-1)[0],
          isRoot: path.length === 0,
          level: path.length,
          circular: null,
          update: function(x, stopHere) {
            if (!state.isRoot) {
              state.parent.node[state.key] = x;
            }
            state.node = x;
            if (stopHere)
              keepGoing = false;
          },
          "delete": function(stopHere) {
            delete state.parent.node[state.key];
            if (stopHere)
              keepGoing = false;
          },
          remove: function(stopHere) {
            if (isArray(state.parent.node)) {
              state.parent.node.splice(state.key, 1);
            } else {
              delete state.parent.node[state.key];
            }
            if (stopHere)
              keepGoing = false;
          },
          keys: null,
          before: function(f) {
            modifiers.before = f;
          },
          after: function(f) {
            modifiers.after = f;
          },
          pre: function(f) {
            modifiers.pre = f;
          },
          post: function(f) {
            modifiers.post = f;
          },
          stop: function() {
            alive = false;
          },
          block: function() {
            keepGoing = false;
          }
        };
        if (!alive)
          return state;
        function updateState() {
          if (typeof state.node === "object" && state.node !== null) {
            if (!state.keys || state.node_ !== state.node) {
              state.keys = objectKeys(state.node);
            }
            state.isLeaf = state.keys.length == 0;
            for (var i = 0; i < parents.length; i++) {
              if (parents[i].node_ === node_) {
                state.circular = parents[i];
                break;
              }
            }
          } else {
            state.isLeaf = true;
            state.keys = null;
          }
          state.notLeaf = !state.isLeaf;
          state.notRoot = !state.isRoot;
        }
        updateState();
        var ret = cb.call(state, state.node);
        if (ret !== void 0 && state.update)
          state.update(ret);
        if (modifiers.before)
          modifiers.before.call(state, state.node);
        if (!keepGoing)
          return state;
        if (typeof state.node == "object" && state.node !== null && !state.circular) {
          parents.push(state);
          updateState();
          forEach(state.keys, function(key, i) {
            path.push(key);
            if (modifiers.pre)
              modifiers.pre.call(state, state.node[key], key);
            var child = walker(state.node[key]);
            if (immutable && hasOwnProperty.call(state.node, key)) {
              state.node[key] = child.node;
            }
            child.isLast = i == state.keys.length - 1;
            child.isFirst = i == 0;
            if (modifiers.post)
              modifiers.post.call(state, child);
            path.pop();
          });
          parents.pop();
        }
        if (modifiers.after)
          modifiers.after.call(state, state.node);
        return state;
      }(root).node;
    }
    function copy(src) {
      if (typeof src === "object" && src !== null) {
        var dst;
        if (isArray(src)) {
          dst = [];
        } else if (isDate(src)) {
          dst = new Date(src.getTime ? src.getTime() : src);
        } else if (isRegExp(src)) {
          dst = new RegExp(src);
        } else if (isError(src)) {
          dst = { message: src.message };
        } else if (isBoolean(src)) {
          dst = new Boolean(src);
        } else if (isNumber(src)) {
          dst = new Number(src);
        } else if (isString(src)) {
          dst = new String(src);
        } else if (Object.create && Object.getPrototypeOf) {
          dst = Object.create(Object.getPrototypeOf(src));
        } else if (src.constructor === Object) {
          dst = {};
        } else {
          var proto = src.constructor && src.constructor.prototype || src.__proto__ || {};
          var T = function() {
          };
          T.prototype = proto;
          dst = new T();
        }
        forEach(objectKeys(src), function(key) {
          dst[key] = src[key];
        });
        return dst;
      } else
        return src;
    }
    var objectKeys = Object.keys || function keys(obj) {
      var res = [];
      for (var key in obj)
        res.push(key);
      return res;
    };
    function toS(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isDate(obj) {
      return toS(obj) === "[object Date]";
    }
    function isRegExp(obj) {
      return toS(obj) === "[object RegExp]";
    }
    function isError(obj) {
      return toS(obj) === "[object Error]";
    }
    function isBoolean(obj) {
      return toS(obj) === "[object Boolean]";
    }
    function isNumber(obj) {
      return toS(obj) === "[object Number]";
    }
    function isString(obj) {
      return toS(obj) === "[object String]";
    }
    var isArray = Array.isArray || function isArray2(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
    var forEach = function(xs, fn) {
      if (xs.forEach)
        return xs.forEach(fn);
      else
        for (var i = 0; i < xs.length; i++) {
          fn(xs[i], i, xs);
        }
    };
    forEach(objectKeys(Traverse.prototype), function(key) {
      traverse[key] = function(obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
      };
    });
    var hasOwnProperty = Object.hasOwnProperty || function(obj, key) {
      return key in obj;
    };
  }
});

// node_modules/@mapbox/extent/index.js
var require_extent = __commonJS({
  "node_modules/@mapbox/extent/index.js"(exports, module) {
    module.exports = Extent;
    function Extent(bbox) {
      if (!(this instanceof Extent)) {
        return new Extent(bbox);
      }
      this._bbox = bbox || [Infinity, Infinity, -Infinity, -Infinity];
      this._valid = !!bbox;
    }
    Extent.prototype.include = function(ll) {
      this._valid = true;
      this._bbox[0] = Math.min(this._bbox[0], ll[0]);
      this._bbox[1] = Math.min(this._bbox[1], ll[1]);
      this._bbox[2] = Math.max(this._bbox[2], ll[0]);
      this._bbox[3] = Math.max(this._bbox[3], ll[1]);
      return this;
    };
    Extent.prototype.equals = function(_) {
      var other;
      if (_ instanceof Extent) {
        other = _.bbox();
      } else {
        other = _;
      }
      return this._bbox[0] == other[0] && this._bbox[1] == other[1] && this._bbox[2] == other[2] && this._bbox[3] == other[3];
    };
    Extent.prototype.center = function(_) {
      if (!this._valid)
        return null;
      return [
        (this._bbox[0] + this._bbox[2]) / 2,
        (this._bbox[1] + this._bbox[3]) / 2
      ];
    };
    Extent.prototype.union = function(_) {
      this._valid = true;
      var other;
      if (_ instanceof Extent) {
        other = _.bbox();
      } else {
        other = _;
      }
      this._bbox[0] = Math.min(this._bbox[0], other[0]);
      this._bbox[1] = Math.min(this._bbox[1], other[1]);
      this._bbox[2] = Math.max(this._bbox[2], other[2]);
      this._bbox[3] = Math.max(this._bbox[3], other[3]);
      return this;
    };
    Extent.prototype.bbox = function() {
      if (!this._valid)
        return null;
      return this._bbox;
    };
    Extent.prototype.contains = function(ll) {
      if (!ll)
        return this._fastContains();
      if (!this._valid)
        return null;
      var lon = ll[0], lat = ll[1];
      return this._bbox[0] <= lon && this._bbox[1] <= lat && this._bbox[2] >= lon && this._bbox[3] >= lat;
    };
    Extent.prototype.intersect = function(_) {
      if (!this._valid)
        return null;
      var other;
      if (_ instanceof Extent) {
        other = _.bbox();
      } else {
        other = _;
      }
      return !(this._bbox[0] > other[2] || this._bbox[2] < other[0] || this._bbox[3] < other[1] || this._bbox[1] > other[3]);
    };
    Extent.prototype._fastContains = function() {
      if (!this._valid)
        return new Function("return null;");
      var body = "return " + this._bbox[0] + "<= ll[0] &&" + this._bbox[1] + "<= ll[1] &&" + this._bbox[2] + ">= ll[0] &&" + this._bbox[3] + ">= ll[1]";
      return new Function("ll", body);
    };
    Extent.prototype.polygon = function() {
      if (!this._valid)
        return null;
      return {
        type: "Polygon",
        coordinates: [
          [
            [this._bbox[0], this._bbox[1]],
            [this._bbox[2], this._bbox[1]],
            [this._bbox[2], this._bbox[3]],
            [this._bbox[0], this._bbox[3]],
            [this._bbox[0], this._bbox[1]]
          ]
        ]
      };
    };
  }
});

// node_modules/@mapbox/geojson-extent/index.js
var require_geojson_extent = __commonJS({
  "node_modules/@mapbox/geojson-extent/index.js"(exports, module) {
    var geojsonCoords = require_geojson_coords();
    var traverse = require_traverse();
    var extent = require_extent();
    var geojsonTypesByDataAttributes = {
      features: ["FeatureCollection"],
      coordinates: ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"],
      geometry: ["Feature"],
      geometries: ["GeometryCollection"]
    };
    var dataAttributes = Object.keys(geojsonTypesByDataAttributes);
    module.exports = function(_) {
      return getExtent(_).bbox();
    };
    module.exports.polygon = function(_) {
      return getExtent(_).polygon();
    };
    module.exports.bboxify = function(_) {
      return traverse(_).map(function(value) {
        if (!value)
          return;
        var isValid = dataAttributes.some(function(attribute) {
          if (value[attribute]) {
            return geojsonTypesByDataAttributes[attribute].indexOf(value.type) !== -1;
          }
          return false;
        });
        if (isValid) {
          value.bbox = getExtent(value).bbox();
          this.update(value);
        }
      });
    };
    function getExtent(_) {
      var ext = extent(), coords = geojsonCoords(_);
      for (var i = 0; i < coords.length; i++)
        ext.include(coords[i]);
      return ext;
    }
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/constrain_feature_movement.js
var require_constrain_feature_movement = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/constrain_feature_movement.js"(exports, module) {
    var extent = require_geojson_extent();
    var Constants = require_constants();
    var { LAT_MIN, LAT_MAX, LAT_RENDERED_MIN, LAT_RENDERED_MAX, LNG_MIN, LNG_MAX } = Constants;
    module.exports = function(geojsonFeatures, delta) {
      let northInnerEdge = LAT_MIN;
      let southInnerEdge = LAT_MAX;
      let northOuterEdge = LAT_MIN;
      let southOuterEdge = LAT_MAX;
      let westEdge = LNG_MAX;
      let eastEdge = LNG_MIN;
      geojsonFeatures.forEach((feature2) => {
        const bounds = extent(feature2);
        const featureSouthEdge = bounds[1];
        const featureNorthEdge = bounds[3];
        const featureWestEdge = bounds[0];
        const featureEastEdge = bounds[2];
        if (featureSouthEdge > northInnerEdge)
          northInnerEdge = featureSouthEdge;
        if (featureNorthEdge < southInnerEdge)
          southInnerEdge = featureNorthEdge;
        if (featureNorthEdge > northOuterEdge)
          northOuterEdge = featureNorthEdge;
        if (featureSouthEdge < southOuterEdge)
          southOuterEdge = featureSouthEdge;
        if (featureWestEdge < westEdge)
          westEdge = featureWestEdge;
        if (featureEastEdge > eastEdge)
          eastEdge = featureEastEdge;
      });
      const constrainedDelta = delta;
      if (northInnerEdge + constrainedDelta.lat > LAT_RENDERED_MAX) {
        constrainedDelta.lat = LAT_RENDERED_MAX - northInnerEdge;
      }
      if (northOuterEdge + constrainedDelta.lat > LAT_MAX) {
        constrainedDelta.lat = LAT_MAX - northOuterEdge;
      }
      if (southInnerEdge + constrainedDelta.lat < LAT_RENDERED_MIN) {
        constrainedDelta.lat = LAT_RENDERED_MIN - southInnerEdge;
      }
      if (southOuterEdge + constrainedDelta.lat < LAT_MIN) {
        constrainedDelta.lat = LAT_MIN - southOuterEdge;
      }
      if (westEdge + constrainedDelta.lng <= LNG_MIN) {
        constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
      }
      if (eastEdge + constrainedDelta.lng >= LNG_MAX) {
        constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
      }
      return constrainedDelta;
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/move_features.js
var require_move_features = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/move_features.js"(exports, module) {
    var constrainFeatureMovement = require_constrain_feature_movement();
    var Constants = require_constants();
    module.exports = function(features, delta) {
      const constrainedDelta = constrainFeatureMovement(
        features.map((feature2) => feature2.toGeoJSON()),
        delta
      );
      features.forEach((feature2) => {
        const currentCoordinates = feature2.getCoordinates();
        const moveCoordinate = (coord) => {
          const point2 = {
            lng: coord[0] + constrainedDelta.lng,
            lat: coord[1] + constrainedDelta.lat
          };
          return [point2.lng, point2.lat];
        };
        const moveRing = (ring) => ring.map((coord) => moveCoordinate(coord));
        const moveMultiPolygon = (multi) => multi.map((ring) => moveRing(ring));
        let nextCoordinates;
        if (feature2.type === Constants.geojsonTypes.POINT) {
          nextCoordinates = moveCoordinate(currentCoordinates);
        } else if (feature2.type === Constants.geojsonTypes.LINE_STRING || feature2.type === Constants.geojsonTypes.MULTI_POINT) {
          nextCoordinates = currentCoordinates.map(moveCoordinate);
        } else if (feature2.type === Constants.geojsonTypes.POLYGON || feature2.type === Constants.geojsonTypes.MULTI_LINE_STRING) {
          nextCoordinates = currentCoordinates.map(moveRing);
        } else if (feature2.type === Constants.geojsonTypes.MULTI_POLYGON) {
          nextCoordinates = currentCoordinates.map(moveMultiPolygon);
        }
        feature2.incomingCoords(nextCoordinates);
      });
    };
  }
});

// node_modules/maplibre-gl-draw-circle/lib/utils/create_supplementary_points_circle.js
var require_create_supplementary_points_circle = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/utils/create_supplementary_points_circle.js"(exports, module) {
    var createVertex = require_create_vertex();
    function createSupplementaryPointsForCircle(geojson) {
      const { properties, geometry } = geojson;
      if (!properties.user_isCircle)
        return null;
      const supplementaryPoints = [];
      const vertices = geometry.coordinates[0].slice(0, -1);
      for (let index = 0; index < vertices.length; index += Math.round(vertices.length / 4)) {
        supplementaryPoints.push(createVertex(properties.id, vertices[index], `0.${index}`, false));
      }
      return supplementaryPoints;
    }
    module.exports = createSupplementaryPointsForCircle;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/modes/DirectModeOverride.js
var require_DirectModeOverride = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/modes/DirectModeOverride.js"(exports, module) {
    var MapboxDraw2 = require_mapbox_gl_draw();
    var createSupplementaryPoints = require_create_supplementary_points();
    var moveFeatures = require_move_features();
    var Constants = require_constants();
    var constrainFeatureMovement = require_constrain_feature_movement();
    var distance2 = require_js5().default;
    var turfHelpers = require_js();
    var circle2 = require_js4().default;
    var createSupplementaryPointsForCircle = require_create_supplementary_points_circle();
    var DirectModeOverride = MapboxDraw2.modes.direct_select;
    DirectModeOverride.dragFeature = function(state, e2, delta) {
      moveFeatures(this.getSelected(), delta);
      this.getSelected().filter((feature2) => feature2.properties.isCircle).map((circle3) => circle3.properties.center).forEach((center) => {
        center[0] += delta.lng;
        center[1] += delta.lat;
      });
      state.dragMoveLocation = e2.lngLat;
    };
    DirectModeOverride.dragVertex = function(state, e2, delta) {
      if (state.feature.properties.isCircle) {
        const center = state.feature.properties.center;
        const movedVertex = [e2.lngLat.lng, e2.lngLat.lat];
        const radius = distance2(turfHelpers.point(center), turfHelpers.point(movedVertex), { units: "kilometers" });
        const circleFeature = circle2(center, radius);
        state.feature.incomingCoords(circleFeature.geometry.coordinates);
        state.feature.properties.radiusInKm = radius;
      } else {
        const selectedCoords = state.selectedCoordPaths.map((coord_path) => state.feature.getCoordinate(coord_path));
        const selectedCoordPoints = selectedCoords.map((coords) => ({
          type: Constants.geojsonTypes.FEATURE,
          properties: {},
          geometry: {
            type: Constants.geojsonTypes.POINT,
            coordinates: coords
          }
        }));
        const constrainedDelta = constrainFeatureMovement(selectedCoordPoints, delta);
        for (let i = 0; i < selectedCoords.length; i++) {
          const coord = selectedCoords[i];
          state.feature.updateCoordinate(state.selectedCoordPaths[i], coord[0] + constrainedDelta.lng, coord[1] + constrainedDelta.lat);
        }
      }
    };
    DirectModeOverride.toDisplayFeatures = function(state, geojson, push) {
      if (state.featureId === geojson.properties.id) {
        geojson.properties.active = Constants.activeStates.ACTIVE;
        push(geojson);
        const supplementaryPoints = geojson.properties.user_isCircle ? createSupplementaryPointsForCircle(geojson) : createSupplementaryPoints(geojson, {
          map: this.map,
          midpoints: true,
          selectedPaths: state.selectedCoordPaths
        });
        supplementaryPoints.forEach(push);
      } else {
        geojson.properties.active = Constants.activeStates.INACTIVE;
        push(geojson);
      }
      this.fireActionable(state);
    };
    module.exports = DirectModeOverride;
  }
});

// node_modules/maplibre-gl-draw-circle/lib/modes/SimpleSelectModeOverride.js
var require_SimpleSelectModeOverride = __commonJS({
  "node_modules/maplibre-gl-draw-circle/lib/modes/SimpleSelectModeOverride.js"(exports, module) {
    var MapboxDraw2 = require_mapbox_gl_draw();
    var createSupplementaryPoints = require_create_supplementary_points();
    var moveFeatures = require_move_features();
    var Constants = require_constants();
    var createSupplementaryPointsForCircle = require_create_supplementary_points_circle();
    var SimpleSelectModeOverride = MapboxDraw2.modes.simple_select;
    SimpleSelectModeOverride.dragMove = function(state, e2) {
      state.dragMoving = true;
      e2.originalEvent.stopPropagation();
      const delta = {
        lng: e2.lngLat.lng - state.dragMoveLocation.lng,
        lat: e2.lngLat.lat - state.dragMoveLocation.lat
      };
      moveFeatures(this.getSelected(), delta);
      this.getSelected().filter((feature2) => feature2.properties.isCircle).map((circle2) => circle2.properties.center).forEach((center) => {
        center[0] += delta.lng;
        center[1] += delta.lat;
      });
      state.dragMoveLocation = e2.lngLat;
    };
    SimpleSelectModeOverride.toDisplayFeatures = function(state, geojson, display) {
      geojson.properties.active = this.isSelected(geojson.properties.id) ? Constants.activeStates.ACTIVE : Constants.activeStates.INACTIVE;
      display(geojson);
      this.fireActionable();
      if (geojson.properties.active !== Constants.activeStates.ACTIVE || geojson.geometry.type === Constants.geojsonTypes.POINT)
        return;
      const supplementaryPoints = geojson.properties.user_isCircle ? createSupplementaryPointsForCircle(geojson) : createSupplementaryPoints(geojson);
      supplementaryPoints.forEach(display);
    };
    module.exports = SimpleSelectModeOverride;
  }
});

// node_modules/maplibre-gl-draw-circle/index.js
var require_maplibre_gl_draw_circle = __commonJS({
  "node_modules/maplibre-gl-draw-circle/index.js"(exports, module) {
    var CircleMode2 = require_CircleMode();
    var DragCircleMode = require_DragCircleMode();
    var DirectMode2 = require_DirectModeOverride();
    var SimpleSelectMode2 = require_SimpleSelectModeOverride();
    module.exports = { CircleMode: CircleMode2, DragCircleMode, DirectMode: DirectMode2, SimpleSelectMode: SimpleSelectMode2 };
  }
});

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyMapLibreRequest.js
var import_maplibre_gl = __toESM(require_maplibre_gl());

// node_modules/maplibre-gl-js-amplify/lib/esm/utils.js
function isCoordinates(array) {
  return Array.isArray(array) && typeof array[0] === "number" && typeof array[1] === "number";
}
function isCoordinatesArray(array) {
  return isCoordinates(array[0]);
}
function isNamedLocation(object) {
  return object && Array.isArray(object.coordinates) && typeof object.coordinates[0] === "number" && typeof object.coordinates[1] === "number";
}
function isNamedLocationArray(array) {
  return isNamedLocation(array[0]);
}
function isGeofence(object) {
  return object && typeof object.geofenceId === "string" && typeof object.geometry === "object";
}
function isGeofenceArray(array) {
  return Array.isArray(array) && isGeofence(array[0]);
}
function isPolygon(object) {
  return Array.isArray(object) && isCoordinatesArray(object[0]);
}
function isPolygonArray(array) {
  return Array.isArray(array) && isPolygon(array[0]);
}
function isGeoJsonSource(source) {
  return source.type === "geojson";
}
var strHasLength = (str) => typeof str === "string" && str.length > 0;
var getFeaturesFromData = (data) => {
  let features;
  if (isCoordinatesArray(data)) {
    features = data.map((point2) => {
      return {
        type: "Feature",
        geometry: { type: "Point", coordinates: point2 },
        properties: { place_name: `Coordinates,${point2}` }
      };
    });
  } else if (isNamedLocationArray(data)) {
    features = data.map((location) => {
      return {
        type: "Feature",
        geometry: { type: "Point", coordinates: location.coordinates },
        properties: { title: location.title, address: location.address }
      };
    });
  } else {
    features = data;
  }
  return features;
};
var urlEncodePeriods = (str) => {
  return str.replace(/\./g, "%2E");
};
function validateCoordinates(coordinates) {
  const [lng, lat] = coordinates;
  if (!Number.isFinite(lng) || !Number.isFinite(lat)) {
    throw new Error(`Invalid coordinates: [${lng},${lat}]`);
  }
  if (lat < -90 || lat > 90) {
    const errorString = "Latitude must be between -90 and 90 degrees inclusive.";
    console.warn(errorString);
    throw new Error(errorString);
  } else if (lng < -180 || lng > 180) {
    const errorString = "Longitude must be between -180 and 180 degrees inclusive.";
    console.warn(errorString);
    throw new Error(errorString);
  }
}
function createElement(tagName, className, container) {
  const el = window.document.createElement(tagName);
  if (className !== void 0)
    el.className = className;
  if (container)
    container.appendChild(el);
  return el;
}
function removeElement(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyMapLibreRequest.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var _a;
var AmplifyMapLibreRequest = class {
  constructor(currentCredentials, region) {
    this.refreshCredentials = () => __awaiter(this, void 0, void 0, function* () {
      try {
        this.credentials = yield Amplify.Auth.currentCredentials();
      } catch (e2) {
        console.error(`Failed to refresh credentials: ${e2}`);
        throw e2;
      }
    });
    this.refreshCredentialsWithRetry = () => __awaiter(this, void 0, void 0, function* () {
      try {
        const MAX_DELAY_MS = 5 * 60 * 1e3;
        yield jitteredExponentialRetry(this.refreshCredentials, [], MAX_DELAY_MS);
        this.activeTimeout && clearTimeout(this.activeTimeout);
        const expiration = new Date(this.credentials.expiration);
        const timeout = expiration.getTime() - new Date().getTime() - 1e4;
        this.activeTimeout = window.setTimeout(this.refreshCredentialsWithRetry, timeout);
      } catch (e2) {
        console.error(`Failed to refresh credentials: ${e2}`);
      }
    });
    this.transformRequest = (url, resourceType) => {
      if (resourceType === "Style" && !url.includes("://")) {
        if (this.region == void 0) {
          throw new Error("AWS region for map is undefined. Please verify that the region is set in aws-exports.js or that you are providing an AWS region parameter to createMap");
        }
        url = `https://maps.geo.${this.region}.amazonaws.com/maps/v0/maps/${url}/style-descriptor`;
      }
      if (url.includes("amazonaws.com")) {
        const urlWithUserAgent = url + `?x-amz-user-agent=${encodeURIComponent(urlEncodePeriods(getAmplifyUserAgent()))}`;
        return {
          url: Signer.signUrl(urlWithUserAgent, {
            access_key: this.credentials.accessKeyId,
            secret_key: this.credentials.secretAccessKey,
            session_token: this.credentials.sessionToken
          })
        };
      }
    };
    this.credentials = currentCredentials;
    this.region = region;
    this.activeTimeout = null;
    this.refreshCredentialsWithRetry();
    Hub.listen("auth", (data) => {
      switch (data.payload.event) {
        case "signIn":
        case "signOut":
        case "tokenRefresh":
          this.refreshCredentialsWithRetry();
          break;
      }
    });
  }
};
_a = AmplifyMapLibreRequest;
AmplifyMapLibreRequest.createMapLibreMap = (options) => __awaiter(void 0, void 0, void 0, function* () {
  const { region, mapConstructor = import_maplibre_gl.Map } = options, maplibreOption = __rest(options, ["region", "mapConstructor"]);
  const defaultMap = Geo.getDefaultMap();
  const amplifyRequest = new AmplifyMapLibreRequest(yield Amplify.Auth.currentCredentials(), region || defaultMap.region);
  const transformRequest = amplifyRequest.transformRequest;
  const map = new mapConstructor(Object.assign(Object.assign({}, maplibreOption), {
    style: options.style || defaultMap.mapName,
    transformRequest
  }));
  return map;
});
var createMap = (options) => __awaiter(void 0, void 0, void 0, function* () {
  return AmplifyMapLibreRequest.createMapLibreMap(options);
});

// node_modules/maplibre-gl-js-amplify/lib/esm/constants.js
var COLOR_WHITE = "#fff";
var COLOR_BLACK = "#000";
var MARKER_COLOR = "#5d8aff";
var ACTIVE_MARKER_COLOR = "#ff9900";
var POPUP_BORDER_COLOR = "#0000001f";
var GEOFENCE_COLOR = "#2194f3";
var GEOFENCE_BORDER_COLOR = "#003560";
var GEOFENCE_VERTEX_COLOR = "#FF9900";
var LOCATION_MARKER = "M24.8133 38.533C18.76 31.493 13 28.8264 13 20.8264C13.4827 14.9864 16.552 9.67169 21.368 6.33302C33.768 -2.26165 50.824 5.78902 52.0667 20.8264C52.0667 28.613 46.5733 31.6797 40.6533 38.373C32.4933 47.5464 35.4 63.093 32.4933 63.093C29.72 63.093 32.4933 47.5464 24.8133 38.533ZM32.4933 8.23969C26.5573 8.23969 21.7467 13.0504 21.7467 18.9864C21.7467 24.9224 26.5573 29.733 32.4933 29.733C38.4293 29.733 43.24 24.9224 43.24 18.9864C43.24 13.0504 38.4293 8.23969 32.4933 8.23969Z";
var MAP_STYLES;
(function(MAP_STYLES2) {
  MAP_STYLES2["ESRI_TOPOGRAPHIC"] = "VectorEsriTopographic";
  MAP_STYLES2["ESRI_STREETS"] = "VectorEsriStreets";
  MAP_STYLES2["ESRI_LIGHT_GRAY"] = "VectorEsriLightGrayCanvas";
  MAP_STYLES2["ESRI_DARK_GRAY"] = "VectorEsriDarkGrayCanvas";
  MAP_STYLES2["ESRI_NAVIGATION"] = "VectorEsriNavigation";
  MAP_STYLES2["HERE_BERLIN"] = "VectorHereBerlin";
})(MAP_STYLES || (MAP_STYLES = {}));
var FONT_DEFAULT_BY_STYLE = {
  [MAP_STYLES.ESRI_TOPOGRAPHIC]: "Noto Sans Regular",
  [MAP_STYLES.ESRI_STREETS]: "Arial Regular",
  [MAP_STYLES.ESRI_LIGHT_GRAY]: "Ubuntu Regular",
  [MAP_STYLES.ESRI_DARK_GRAY]: "Ubuntu Regular",
  [MAP_STYLES.ESRI_NAVIGATION]: "Arial Regular",
  [MAP_STYLES.HERE_BERLIN]: "Fira GO Regular"
};

// node_modules/maplibre-gl-js-amplify/lib/esm/drawClusterLayer.js
function drawClusterLayer(sourceName, map, { fillColor: markerColor = MARKER_COLOR, smCircleSize: smallSize = 60, smThreshold: smallThreshold = 50, mdCircleSize: mediumSize = 100, mdThreshold: mediumThreshold = 100, lgCircleSize: largeSize = 140, lgThreshold: largeThreshold = 500, xlCircleSize: extraLargeSize = 180, borderWidth = 4, borderColor = COLOR_WHITE, clusterPaint, onClick, showCount, clusterCountLayout, fontColor = COLOR_WHITE }, mapStyle) {
  const clusterLayerId = `${sourceName}-layer-clusters`;
  const clusterSymbolLayerId = `${sourceName}-layer-cluster-count`;
  const paintOptions = Object.assign({ "circle-color": [
    "step",
    ["get", "point_count"],
    markerColor,
    smallThreshold,
    markerColor,
    mediumThreshold,
    markerColor,
    largeThreshold,
    markerColor
  ], "circle-radius": [
    "step",
    ["get", "point_count"],
    smallSize,
    smallThreshold,
    mediumSize,
    mediumThreshold,
    largeSize,
    largeThreshold,
    extraLargeSize
  ], "circle-stroke-width": borderWidth, "circle-stroke-color": borderColor }, clusterPaint);
  const defaultClusterLayer = {
    id: clusterLayerId,
    type: "circle",
    source: sourceName,
    filter: ["has", "point_count"],
    paint: paintOptions
  };
  map.addLayer(Object.assign({}, defaultClusterLayer));
  map.on("click", clusterLayerId, function(e2) {
    if (typeof onClick === "function")
      onClick(e2);
    const features = map.queryRenderedFeatures(e2.point, {
      layers: [clusterLayerId]
    });
    const clusterId = features[0].properties.cluster_id;
    const source = map.getSource(sourceName);
    if (isGeoJsonSource(source)) {
      source.getClusterExpansionZoom(clusterId, function(err, zoom) {
        if (err)
          return;
        map.easeTo({
          center: features[0].geometry.coordinates,
          zoom
        });
      });
    }
  });
  if (showCount) {
    const defaultLayoutOptions = {
      "text-field": "{point_count_abbreviated}",
      "text-size": 24
    };
    const locationServiceStyle = mapStyle || Geo.getDefaultMap().style;
    if (locationServiceStyle) {
      defaultLayoutOptions["text-font"] = [
        FONT_DEFAULT_BY_STYLE[locationServiceStyle]
      ];
    }
    const layoutOptions = Object.assign(Object.assign({}, defaultLayoutOptions), clusterCountLayout);
    const paintOptions2 = {
      "text-color": fontColor
    };
    const defaultClusterCount = {
      id: clusterSymbolLayerId,
      type: "symbol",
      source: sourceName,
      filter: ["has", "point_count"],
      layout: layoutOptions,
      paint: paintOptions2
    };
    map.addLayer(Object.assign({}, defaultClusterCount));
  }
  return { clusterLayerId, clusterSymbolLayerId };
}

// node_modules/maplibre-gl-js-amplify/lib/esm/drawUnclusteredLayer.js
var import_maplibre_gl2 = __toESM(require_maplibre_gl());

// node_modules/maplibre-gl-js-amplify/lib/esm/createMarker.js
function createMarker(options) {
  const fillColor = (options === null || options === void 0 ? void 0 : options.fillColor) ? options.fillColor : MARKER_COLOR;
  const strokeColor = (options === null || options === void 0 ? void 0 : options.strokeColor) ? options.strokeColor : COLOR_WHITE;
  const lineWidth = (options === null || options === void 0 ? void 0 : options.lineWidth) ? options.lineWidth : 4;
  return {
    width: 64,
    height: 64,
    data: new Uint8Array(64 * 64 * 4),
    onAdd: function() {
      const canvas = document.createElement("canvas");
      canvas.width = this.width;
      canvas.height = this.height;
      this.context = canvas.getContext("2d");
    },
    render: function() {
      const context = this.context;
      const markerShape = new Path2D(LOCATION_MARKER);
      context.stroke(markerShape);
      context.fillStyle = fillColor;
      context.strokeStyle = strokeColor;
      context.lineWidth = lineWidth;
      context.fill(markerShape);
      this.data = context.getImageData(0, 0, this.width, this.height).data;
      return true;
    }
  };
}

// node_modules/maplibre-gl-js-amplify/lib/esm/popupRender.js
function getPopupRenderFunction(unclusteredLayerId, { popupBackgroundColor: background = COLOR_WHITE, popupBorderColor: borderColor = POPUP_BORDER_COLOR, popupBorderWidth: borderWidth = 2, popupFontColor: fontColor = COLOR_BLACK, popupPadding: padding = 20, popupBorderRadius: radius = 4, popupTitleFontWeight: fontWeight = "bold" }) {
  return (selectedFeature) => {
    let title, address;
    if (strHasLength(selectedFeature.properties.place_name)) {
      const placeName = selectedFeature.properties.place_name.split(",");
      title = placeName[0];
      address = placeName.splice(1, placeName.length).join(",");
    } else if (strHasLength(selectedFeature.properties.title) || strHasLength(selectedFeature.properties.address)) {
      title = selectedFeature.properties.title;
      address = selectedFeature.properties.address;
    } else {
      title = "Coordinates";
      address = selectedFeature.geometry.coordinates;
    }
    const titleHtml = `<div class="${unclusteredLayerId}-popup-title" style="font-weight: ${fontWeight};">${title}</div>`;
    const addressHtml = `<div class="${unclusteredLayerId}-popup-address">${address}</div>`;
    const popupHtmlStyle = `background: ${background}; border: ${borderWidth}px solid ${borderColor}; color: ${fontColor}; border-radius: ${radius}px; padding: ${padding}px; word-wrap: break-word; margin: -10px -10px -15px;`;
    let popupHtml = `<div class="${unclusteredLayerId}-popup" style="${popupHtmlStyle}">`;
    if (title)
      popupHtml += titleHtml;
    if (address)
      popupHtml += addressHtml;
    popupHtml += "</div>";
    return popupHtml;
  };
}

// node_modules/maplibre-gl-js-amplify/lib/esm/drawUnclusteredLayer.js
var __rest2 = function(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var HIDE_TIP = "amplify-tip";
function drawUnclusteredLayer(sourceName, map, _a2) {
  var { showMarkerPopup = false } = _a2, options = __rest2(_a2, ["showMarkerPopup"]);
  const unclusteredLayerId = `${sourceName}-layer-unclustered-point`;
  let selectedId = null;
  function deselectPoint() {
    if (selectedId !== null) {
      map.setLayoutProperty(unclusteredLayerId, "icon-image", "inactive-marker");
      selectedId = null;
    }
  }
  const popupRender = options.popupRender ? options.popupRender : getPopupRenderFunction(unclusteredLayerId, options);
  addUnclusteredMarkerImages(map, options);
  const defaultUnclusteredPoint = {
    id: unclusteredLayerId,
    type: "symbol",
    source: sourceName,
    filter: ["!", ["has", "point_count"]],
    layout: {
      "icon-image": "inactive-marker"
    }
  };
  map.addLayer(Object.assign({}, defaultUnclusteredPoint));
  if (showMarkerPopup) {
    const element = document.getElementById(HIDE_TIP);
    if (!element) {
      const style = document.createElement("style");
      style.setAttribute("id", HIDE_TIP);
      document.head.append(style);
      style.textContent = ".mapboxgl-popup-tip { display: none; }";
    }
  }
  map.on("click", function() {
    deselectPoint();
  });
  map.on("click", unclusteredLayerId, function(e2) {
    if (typeof options.onClick === "function")
      options.onClick(e2);
    selectedId = e2.features[0].id;
    map.setLayoutProperty(unclusteredLayerId, "icon-image", [
      "match",
      ["id"],
      selectedId,
      "active-marker",
      "inactive-marker"
    ]);
    if (showMarkerPopup) {
      const selectedFeature = e2.features[0];
      const coordinates = selectedFeature.geometry.coordinates;
      if (isCoordinates(coordinates)) {
        const popup = new import_maplibre_gl2.Popup().setLngLat(coordinates).setHTML(popupRender(selectedFeature)).setOffset(15).addTo(map);
        popup.on("close", function() {
          if (selectedId === selectedFeature.id)
            deselectPoint();
        });
      }
    }
  });
  map.on("mouseover", unclusteredLayerId, function() {
    map.getCanvas().style.cursor = "pointer";
  });
  map.on("mouseleave", unclusteredLayerId, () => {
    map.getCanvas().style.cursor = "";
  });
  return { unclusteredLayerId };
}
function addUnclusteredMarkerImages(map, { selectedColor = ACTIVE_MARKER_COLOR, selectedBorderColor = COLOR_WHITE, selectedBorderWidth = 4, defaultBorderColor = COLOR_WHITE, defaultBorderWidth = 4, defaultColor: fillColor = MARKER_COLOR, markerImageElement, activeMarkerImageElement }) {
  const inactiveMarker = markerImageElement || createMarker({
    fillColor,
    strokeColor: defaultBorderColor,
    lineWidth: defaultBorderWidth
  });
  const activeMarker = activeMarkerImageElement || markerImageElement || createMarker({
    fillColor: selectedColor,
    strokeColor: selectedBorderColor,
    lineWidth: selectedBorderWidth
  });
  map.addImage("inactive-marker", inactiveMarker, { pixelRatio: 2 });
  map.addImage("active-marker", activeMarker, { pixelRatio: 2 });
}

// node_modules/maplibre-gl-js-amplify/lib/esm/drawPoints.js
function drawPoints(sourceName, data, map, { showCluster = true, clusterOptions = {}, unclusteredOptions: unclusteredMarkerOptions = {}, autoFit = true } = {}, mapStyle) {
  var _a2, _b;
  if (!map || typeof map.addSource !== "function" || typeof map.addLayer !== "function") {
    throw new Error("Please use a maplibre map");
  }
  const features = getFeaturesFromData(data);
  const sourceId = sourceName;
  map.addSource(sourceId, {
    type: "geojson",
    data: {
      type: "FeatureCollection",
      features
    },
    cluster: showCluster,
    clusterMaxZoom: (_a2 = clusterOptions.clusterMaxZoom) !== null && _a2 !== void 0 ? _a2 : 14,
    clusterRadius: (_b = clusterOptions.smCircleSize) !== null && _b !== void 0 ? _b : 60,
    generateId: true
  });
  let clusterLayerId, clusterSymbolLayerId;
  if (showCluster) {
    ({ clusterLayerId, clusterSymbolLayerId } = drawClusterLayer(sourceId, map, clusterOptions, mapStyle));
  }
  const { unclusteredLayerId } = drawUnclusteredLayer(sourceId, map, unclusteredMarkerOptions || {});
  if (autoFit) {
    const mapBounds = map.getBounds();
    features.forEach(function(feature2) {
      mapBounds.extend(feature2.geometry.coordinates);
    });
    map.fitBounds(mapBounds);
  }
  const hide = () => {
    map.setLayoutProperty(unclusteredLayerId, "visibility", "none");
    if (clusterLayerId)
      map.setLayoutProperty(clusterLayerId, "visibility", "none");
    if (clusterSymbolLayerId)
      map.setLayoutProperty(clusterSymbolLayerId, "visibility", "none");
  };
  const show = () => {
    map.setLayoutProperty(unclusteredLayerId, "visibility", "visible");
    if (clusterLayerId)
      map.setLayoutProperty(clusterLayerId, "visibility", "visible");
    if (clusterSymbolLayerId)
      map.setLayoutProperty(clusterSymbolLayerId, "visibility", "visible");
  };
  const setData = (data2) => {
    const features2 = getFeaturesFromData(data2);
    map.getSource(sourceId).setData({
      type: "FeatureCollection",
      features: features2
    });
  };
  return {
    sourceId,
    unclusteredLayerId,
    clusterLayerId,
    clusterSymbolLayerId,
    setData,
    show,
    hide
  };
}

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyMapLibreGeocoder.js
var import_maplibre_gl_geocoder = __toESM(require_lib());
var import_maplibre_gl3 = __toESM(require_maplibre_gl());

// node_modules/maplibre-gl-js-amplify/lib/esm/createDefaultIcon.js
function createDefaultIcon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  const iconPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  const iconCircle = document.createElement("circle");
  customIcon.setAttribute("viewBox", "0 0 64 64");
  customIcon.setAttribute("width", "32");
  customIcon.setAttribute("height", "32");
  iconPath.setAttribute("d", LOCATION_MARKER);
  iconPath.setAttribute("fill", "#5d8aff");
  iconCircle.setAttribute("fill", "white");
  iconCircle.setAttribute("cx", "50%");
  iconCircle.setAttribute("cy", "50%");
  iconCircle.setAttribute("r", "5");
  customIcon.appendChild(iconCircle);
  customIcon.appendChild(iconPath);
  return customIcon;
}

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyMapLibreGeocoder.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest3 = function(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var AmplifyGeocoderAPI = {
  forwardGeocode: (config) => __awaiter2(void 0, void 0, void 0, function* () {
    const features = [];
    try {
      const data = yield Geo.searchByText(config.query, {
        biasPosition: config.bbox ? void 0 : config.proximity,
        searchAreaConstraints: config.bbox,
        countries: config.countries,
        maxResults: config.limit
      });
      if (data) {
        data.forEach((result) => {
          const { geometry } = result, otherResults = __rest3(result, ["geometry"]);
          features.push({
            type: "Feature",
            geometry: { type: "Point", coordinates: geometry.point },
            properties: Object.assign({}, otherResults),
            place_name: otherResults.label,
            text: otherResults.label,
            center: geometry.point
          });
        });
      }
    } catch (e2) {
      console.error(`Failed to forwardGeocode with error: ${e2}`);
    }
    return { features };
  }),
  reverseGeocode: (config) => __awaiter2(void 0, void 0, void 0, function* () {
    const features = [];
    try {
      const data = yield Geo.searchByCoordinates(config.query, {
        maxResults: config.limit
      });
      if (data && data.geometry) {
        const { geometry } = data, otherResults = __rest3(data, ["geometry"]);
        features.push({
          type: "Feature",
          geometry: { type: "Point", coordinates: geometry.point },
          properties: Object.assign({}, otherResults),
          place_name: otherResults.label,
          text: otherResults.label,
          center: geometry.point
        });
      }
    } catch (e2) {
      console.error(`Failed to reverseGeocode with error: ${e2}`);
    }
    return { features };
  })
};
function createAmplifyGeocoder(options) {
  return new import_maplibre_gl_geocoder.default(AmplifyGeocoderAPI, Object.assign({
    maplibregl: import_maplibre_gl3.default,
    showResultMarkers: { element: createDefaultIcon() },
    marker: { element: createDefaultIcon() },
    showResultsWhileTyping: options === null || options === void 0 ? void 0 : options.autocomplete
  }, options));
}

// node_modules/@turf/bearing/dist/es/index.js
function bearing(start, end, options) {
  if (options === void 0) {
    options = {};
  }
  if (options.final === true) {
    return calculateFinalBearing(start, end);
  }
  var coordinates1 = getCoord(start);
  var coordinates2 = getCoord(end);
  var lon1 = degreesToRadians(coordinates1[0]);
  var lon2 = degreesToRadians(coordinates2[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
  return radiansToDegrees(Math.atan2(a, b));
}
function calculateFinalBearing(start, end) {
  var bear = bearing(end, start);
  bear = (bear + 180) % 360;
  return bear;
}

// node_modules/@turf/destination/dist/es/index.js
function destination(origin, distance2, bearing2, options) {
  if (options === void 0) {
    options = {};
  }
  var coordinates1 = getCoord(origin);
  var longitude1 = degreesToRadians(coordinates1[0]);
  var latitude1 = degreesToRadians(coordinates1[1]);
  var bearingRad = degreesToRadians(bearing2);
  var radians = lengthToRadians(distance2, options.units);
  var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) + Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
  var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
  var lng = radiansToDegrees(longitude2);
  var lat = radiansToDegrees(latitude2);
  return point([lng, lat], options.properties);
}

// node_modules/@turf/distance/dist/es/index.js
function distance(from, to, options) {
  if (options === void 0) {
    options = {};
  }
  var coordinates1 = getCoord(from);
  var coordinates2 = getCoord(to);
  var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
  var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
  var lat1 = degreesToRadians(coordinates1[1]);
  var lat2 = degreesToRadians(coordinates2[1]);
  var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
var es_default = distance;

// node_modules/@turf/along/dist/es/index.js
function along(line, distance2, options) {
  if (options === void 0) {
    options = {};
  }
  var geom = getGeom(line);
  var coords = geom.coordinates;
  var travelled = 0;
  for (var i = 0; i < coords.length; i++) {
    if (distance2 >= travelled && i === coords.length - 1) {
      break;
    } else if (travelled >= distance2) {
      var overshot = distance2 - travelled;
      if (!overshot) {
        return point(coords[i]);
      } else {
        var direction = bearing(coords[i], coords[i - 1]) - 180;
        var interpolated = destination(coords[i], overshot, direction, options);
        return interpolated;
      }
    } else {
      travelled += es_default(coords[i], coords[i + 1], options);
    }
  }
  return point(coords[coords.length - 1]);
}

// node_modules/@turf/circle/dist/es/index.js
function circle(center, radius, options) {
  if (options === void 0) {
    options = {};
  }
  var steps = options.steps || 64;
  var properties = options.properties ? options.properties : !Array.isArray(center) && center.type === "Feature" && center.properties ? center.properties : {};
  var coordinates = [];
  for (var i = 0; i < steps; i++) {
    coordinates.push(destination(center, radius, i * -360 / steps, options).geometry.coordinates);
  }
  coordinates.push(coordinates[0]);
  return polygon([coordinates], properties);
}
var es_default2 = circle;

// node_modules/@turf/meta/dist/es/index.js
function coordEach(geojson, callback, excludeWrapCoord) {
  if (geojson === null)
    return;
  var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
      var multiFeatureIndex = 0;
      var geometryIndex = 0;
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
      if (geometry === null)
        continue;
      coords = geometry.coordinates;
      var geomType = geometry.type;
      wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
      switch (geomType) {
        case null:
          break;
        case "Point":
          if (callback(
            coords,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          ) === false)
            return false;
          coordIndex++;
          multiFeatureIndex++;
          break;
        case "LineString":
        case "MultiPoint":
          for (j = 0; j < coords.length; j++) {
            if (callback(
              coords[j],
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            if (geomType === "MultiPoint")
              multiFeatureIndex++;
          }
          if (geomType === "LineString")
            multiFeatureIndex++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (j = 0; j < coords.length; j++) {
            for (k = 0; k < coords[j].length - wrapShrink; k++) {
              if (callback(
                coords[j][k],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
            }
            if (geomType === "MultiLineString")
              multiFeatureIndex++;
            if (geomType === "Polygon")
              geometryIndex++;
          }
          if (geomType === "Polygon")
            multiFeatureIndex++;
          break;
        case "MultiPolygon":
          for (j = 0; j < coords.length; j++) {
            geometryIndex = 0;
            for (k = 0; k < coords[j].length; k++) {
              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                if (callback(
                  coords[j][k][l],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              geometryIndex++;
            }
            multiFeatureIndex++;
          }
          break;
        case "GeometryCollection":
          for (j = 0; j < geometry.geometries.length; j++)
            if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
              return false;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function geomEach(geojson, callback) {
  var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
  for (i = 0; i < stop; i++) {
    geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
    featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
    featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
    featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
    isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
    stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
    for (g = 0; g < stopG; g++) {
      geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
      if (geometry === null) {
        if (callback(
          null,
          featureIndex,
          featureProperties,
          featureBBox,
          featureId
        ) === false)
          return false;
        continue;
      }
      switch (geometry.type) {
        case "Point":
        case "LineString":
        case "MultiPoint":
        case "Polygon":
        case "MultiLineString":
        case "MultiPolygon": {
          if (callback(
            geometry,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          break;
        }
        case "GeometryCollection": {
          for (j = 0; j < geometry.geometries.length; j++) {
            if (callback(
              geometry.geometries[j],
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
          }
          break;
        }
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
    featureIndex++;
  }
}
function flattenEach(geojson, callback) {
  geomEach(geojson, function(geometry, featureIndex, properties, bbox, id) {
    var type = geometry === null ? null : geometry.type;
    switch (type) {
      case null:
      case "Point":
      case "LineString":
      case "Polygon":
        if (callback(
          feature(geometry, properties, { bbox, id }),
          featureIndex,
          0
        ) === false)
          return false;
        return;
    }
    var geomType;
    switch (type) {
      case "MultiPoint":
        geomType = "Point";
        break;
      case "MultiLineString":
        geomType = "LineString";
        break;
      case "MultiPolygon":
        geomType = "Polygon";
        break;
    }
    for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
      var coordinate = geometry.coordinates[multiFeatureIndex];
      var geom = {
        type: geomType,
        coordinates: coordinate
      };
      if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
        return false;
    }
  });
}
function segmentEach(geojson, callback) {
  flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
    var segmentIndex = 0;
    if (!feature2.geometry)
      return;
    var type = feature2.geometry.type;
    if (type === "Point" || type === "MultiPoint")
      return;
    var previousCoords;
    var previousFeatureIndex = 0;
    var previousMultiIndex = 0;
    var prevGeomIndex = 0;
    if (coordEach(
      feature2,
      function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
        if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
          previousCoords = currentCoord;
          previousFeatureIndex = featureIndex;
          previousMultiIndex = multiPartIndexCoord;
          prevGeomIndex = geometryIndex;
          segmentIndex = 0;
          return;
        }
        var currentSegment = lineString(
          [previousCoords, currentCoord],
          feature2.properties
        );
        if (callback(
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        ) === false)
          return false;
        segmentIndex++;
        previousCoords = currentCoord;
      }
    ) === false)
      return false;
  });
}
function segmentReduce(geojson, callback, initialValue) {
  var previousValue = initialValue;
  var started = false;
  segmentEach(
    geojson,
    function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
      if (started === false && initialValue === void 0)
        previousValue = currentSegment;
      else
        previousValue = callback(
          previousValue,
          currentSegment,
          featureIndex,
          multiFeatureIndex,
          geometryIndex,
          segmentIndex
        );
      started = true;
    }
  );
  return previousValue;
}

// node_modules/@turf/length/dist/es/index.js
function length(geojson, options) {
  if (options === void 0) {
    options = {};
  }
  return segmentReduce(geojson, function(previousValue, segment) {
    var coords = segment.geometry.coordinates;
    return previousValue + es_default(coords[0], coords[1], options);
  }, 0);
}

// node_modules/maplibre-gl-js-amplify/lib/esm/geofenceUtils.js
var GEOFENCE_ID_REGEX = /^[-._\p{L}\p{N}]+$/iu;
var getGeofenceFeatureArray = (data) => {
  const coordinates = isGeofenceArray(data) ? data.map((geofence) => geofence.geometry.polygon) : data;
  return {
    type: "Feature",
    geometry: {
      type: "MultiPolygon",
      coordinates
    },
    properties: {}
  };
};
var getGeofenceFeatureFromPolygon = (polygon2) => {
  return {
    type: "Feature",
    geometry: {
      type: "Polygon",
      coordinates: polygon2
    },
    properties: {}
  };
};
var getPolygonFeatureFromBounds = (id, bounds) => {
  const swCoordinate = bounds.getSouthWest().toArray();
  const neCoordinate = bounds.getNorthEast().toArray();
  const center = bounds.getCenter().toArray();
  const line = lineString([swCoordinate, center, neCoordinate]);
  const distanceInMiles = length(line, { units: "miles" });
  const southWestCoordinate = along(line, distanceInMiles / 4, {
    units: "miles"
  }).geometry.coordinates;
  const northeastCoordinate = along(line, distanceInMiles * (3 / 4), {
    units: "miles"
  }).geometry.coordinates;
  const polygon2 = [
    [
      northeastCoordinate,
      [southWestCoordinate[0], northeastCoordinate[1]],
      southWestCoordinate,
      [northeastCoordinate[0], southWestCoordinate[1]],
      northeastCoordinate
    ]
  ];
  return {
    id,
    type: "Feature",
    geometry: {
      type: "Polygon",
      coordinates: polygon2
    },
    properties: {}
  };
};
var getCircleFeatureFromCoords = (id, center, { bounds, radius }) => {
  if (!bounds && !radius) {
    throw new Error("Circle requires a bounds or a radius");
  }
  validateCoordinates(center);
  const circleRadius = radius !== null && radius !== void 0 ? radius : getDistanceFromBounds(bounds) / 8;
  const circleFeature = es_default2(center, circleRadius, { units: "miles" });
  return {
    id,
    type: "Feature",
    properties: {
      isCircle: true,
      center,
      radius: circleRadius
    },
    geometry: {
      type: "Polygon",
      coordinates: circleFeature.geometry.coordinates
    }
  };
};
var getDistanceFromBounds = (bounds) => {
  const swCoordinate = bounds.getSouthWest().toArray();
  const neCoordinate = bounds.getNorthEast().toArray();
  const center = bounds.getCenter().toArray();
  const line = lineString([swCoordinate, center, neCoordinate]);
  return length(line, { units: "miles" });
};
var doesGeofenceExist = (id, loadedGeofences) => {
  return !!loadedGeofences[id];
};
var isValidGeofenceId = (id) => {
  return !!id.match(GEOFENCE_ID_REGEX);
};
var isExistingGeofenceId = (id, loadedGeofences) => {
  return doesGeofenceExist(id, loadedGeofences);
};
var getDistanceBetweenCoordinates = (startCoord, endCoord) => {
  const line = lineString([startCoord, endCoord]);
  const distanceInMiles = length(line, { units: "miles" });
  return distanceInMiles;
};

// node_modules/maplibre-gl-js-amplify/lib/esm/drawGeofences.js
var FILL_OPACITY = 0.3;
var BORDER_OPACITY = 0.5;
var BORDER_WIDTH = 4;
function drawGeofences(sourceName, data, map, options = {}) {
  var _a2, _b, _c, _d, _e, _f, _g, _h;
  if (!map || typeof map.addSource !== "function" || typeof map.addLayer !== "function") {
    throw new Error("Please use a maplibre map");
  }
  if (data.length > 0 && !isGeofenceArray(data) && !isPolygonArray(data)) {
    throw new Error("Please pass in an array of Geofences or an array of Polygons");
  }
  const sourceId = `${sourceName}`;
  map.addSource(sourceId, {
    type: "geojson",
    data: getGeofenceFeatureArray(data),
    generateId: true
  });
  const initialVisiblity = ((_a2 = options.visible) !== null && _a2 !== void 0 ? _a2 : true) ? "visible" : "none";
  const fillLayerId = `${sourceName}-fill-layer`;
  map.addLayer({
    id: fillLayerId,
    type: "fill",
    source: sourceId,
    layout: {
      visibility: initialVisiblity
    },
    paint: {
      "fill-color": (_b = options.fillColor) !== null && _b !== void 0 ? _b : COLOR_BLACK,
      "fill-opacity": (_c = options.fillOpacity) !== null && _c !== void 0 ? _c : FILL_OPACITY
    }
  });
  const outlineLayerId = `${sourceName}-outline-layer`;
  map.addLayer({
    id: outlineLayerId,
    type: "line",
    source: sourceId,
    layout: {
      visibility: initialVisiblity
    },
    paint: {
      "line-color": (_d = options.borderColor) !== null && _d !== void 0 ? _d : COLOR_BLACK,
      "line-opacity": (_e = options.borderOpacity) !== null && _e !== void 0 ? _e : BORDER_OPACITY,
      "line-width": (_f = options.borderWidth) !== null && _f !== void 0 ? _f : BORDER_WIDTH,
      "line-offset": (_g = options.borderOffset) !== null && _g !== void 0 ? _g : ((_h = options.borderWidth) !== null && _h !== void 0 ? _h : BORDER_WIDTH) / 2 * -1
    }
  });
  const hide = () => {
    map.setLayoutProperty(fillLayerId, "visibility", "none");
    map.setLayoutProperty(outlineLayerId, "visibility", "none");
  };
  const show = () => {
    map.setLayoutProperty(fillLayerId, "visibility", "visible");
    map.setLayoutProperty(outlineLayerId, "visibility", "visible");
  };
  const isVisible = () => {
    const visibility = map.getLayoutProperty(fillLayerId, "visibility");
    return visibility === "visible";
  };
  const setData = (data2) => {
    map.getSource(sourceId).setData(data2);
  };
  return {
    sourceId,
    outlineLayerId,
    fillLayerId,
    show,
    hide,
    isVisible,
    setData
  };
}

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyGeofenceControl/index.js
var import_maplibre_gl4 = __toESM(require_maplibre_gl());

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyGeofenceControl/ui.js
var import_debounce = __toESM(require_debounce());

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyGeofenceControl/icons.js
var EDIT_ICON_PATH = "M0.5 12.375V15.5H3.625L12.8417 6.28333L9.71667 3.15833L0.5 12.375ZM2.93333 13.8333H2.16667V13.0667L9.71667 5.51667L10.4833 6.28333L2.93333 13.8333ZM15.2583 2.69167L13.3083 0.741667C13.1417 0.575 12.9333 0.5 12.7167 0.5C12.5 0.5 12.2917 0.583333 12.1333 0.741667L10.6083 2.26667L13.7333 5.39167L15.2583 3.86667C15.5833 3.54167 15.5833 3.01667 15.2583 2.69167Z";
function createEditIcon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  const iconPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  customIcon.setAttribute("viewBox", "0 0 16 16");
  customIcon.setAttribute("width", "16");
  customIcon.setAttribute("height", "16");
  customIcon.setAttribute("fill", "none");
  iconPath.setAttribute("d", EDIT_ICON_PATH);
  iconPath.setAttribute("fill", "white");
  customIcon.appendChild(iconPath);
  return customIcon;
}
var TRASH_ICON_PATH = "M9.33317 5.5V13.8333H2.6665V5.5H9.33317ZM8.08317 0.5H3.9165L3.08317 1.33333H0.166504V3H11.8332V1.33333H8.9165L8.08317 0.5ZM10.9998 3.83333H0.999837V13.8333C0.999837 14.75 1.74984 15.5 2.6665 15.5H9.33317C10.2498 15.5 10.9998 14.75 10.9998 13.8333V3.83333Z";
function createTrashIcon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  const iconPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
  customIcon.setAttribute("viewBox", "0 0 12 16");
  customIcon.setAttribute("width", "12");
  customIcon.setAttribute("height", "16");
  customIcon.setAttribute("fill", "none");
  iconPath.setAttribute("d", TRASH_ICON_PATH);
  iconPath.setAttribute("fill", "white");
  customIcon.appendChild(iconPath);
  return customIcon;
}
function createPopupStep1Icon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  customIcon.setAttribute("viewBox", "0 0 38 38");
  customIcon.setAttribute("width", "38");
  customIcon.setAttribute("height", "38");
  customIcon.setAttribute("fill", "none");
  const circle2 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle2.setAttribute("cx", "19");
  circle2.setAttribute("cy", "18");
  circle2.setAttribute("r", "8");
  circle2.setAttribute("fill", "#FF9900");
  const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path1.setAttribute("d", "M19 0L23.3302 7.5H14.6699L19 0Z");
  path1.setAttribute("fill", "#003560");
  const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path2.setAttribute("d", "M19 36.5L14.6698 29H23.3301L19 36.5Z");
  path2.setAttribute("fill", "#003560");
  const path3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path3.setAttribute("d", "M0 18.33L7.5 13.9999L7.5 22.6602L0 18.33Z");
  path3.setAttribute("fill", "#003560");
  const path4 = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path4.setAttribute("d", "M37.5 18.3301L30 22.6603V14L37.5 18.3301Z");
  path4.setAttribute("fill", "#003560");
  customIcon.appendChild(circle2);
  customIcon.appendChild(path1);
  customIcon.appendChild(path2);
  customIcon.appendChild(path3);
  customIcon.appendChild(path4);
  return customIcon;
}
function createPopupStep2Icon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  customIcon.setAttribute("viewBox", "0 0 42 27");
  customIcon.setAttribute("width", "42");
  customIcon.setAttribute("height", "27");
  customIcon.setAttribute("fill", "none");
  const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
  line.setAttribute("y1", "8");
  line.setAttribute("x2", "42");
  line.setAttribute("y2", "8");
  line.setAttribute("stroke", "black");
  line.setAttribute("stroke-width", "2");
  const circle2 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
  circle2.setAttribute("cx", "21");
  circle2.setAttribute("cy", "8");
  circle2.setAttribute("r", "8");
  circle2.setAttribute("fill", "#FF9900");
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", "M21 6.17822V22.488L24.6951 19.4356L27.172 26.1782L29.0399 25.3582L26.6035 18.57L31.4762 17.9322L21 6.17822Z");
  path.setAttribute("fill", "#003560");
  customIcon.appendChild(line);
  customIcon.appendChild(circle2);
  customIcon.appendChild(path);
  return customIcon;
}
function createPopupStep3Icon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  customIcon.setAttribute("viewBox", "0 0 32 32");
  customIcon.setAttribute("width", "32");
  customIcon.setAttribute("height", "32");
  customIcon.setAttribute("fill", "none");
  const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  rect.setAttribute("y", "1");
  rect.setAttribute("x", "1");
  rect.setAttribute("width", "30");
  rect.setAttribute("height", "30");
  rect.setAttribute("fill", "#2196F3");
  rect.setAttribute("fill-opacity", "0.4");
  rect.setAttribute("stroke", "#003560");
  rect.setAttribute("stroke-width", "2");
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", "M11 6V22.3098L14.6951 19.2574L17.172 26L19.0399 25.18L16.6035 18.3918L21.4762 17.754L11 6Z");
  path.setAttribute("fill", "#003560");
  customIcon.appendChild(rect);
  customIcon.appendChild(path);
  return customIcon;
}
function createPopupStep4Icon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  customIcon.setAttribute("viewBox", "0 0 64 20");
  customIcon.setAttribute("width", "64");
  customIcon.setAttribute("height", "20");
  customIcon.setAttribute("fill", "none");
  const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
  rect.setAttribute("y", "0.5");
  rect.setAttribute("x", "0.5");
  rect.setAttribute("width", "63");
  rect.setAttribute("height", "19");
  rect.setAttribute("rx", "3.5");
  rect.setAttribute("stroke", "#014478");
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", "M14.4148 15C17.517 15 19.3118 13.076 19.3118 9.89418C19.3118 6.72727 17.517 4.81818 14.5192 4.81818H11.1186V15H14.4148ZM12.6548 13.6577V6.16051H14.4247C16.652 6.16051 17.8004 7.4929 17.8004 9.89418C17.8004 12.3054 16.652 13.6577 14.3303 13.6577H12.6548ZM24.394 15.1541C26.0595 15.1541 27.2377 14.3338 27.5758 13.0909L26.1689 12.8374C25.9004 13.5582 25.2541 13.9261 24.4089 13.9261C23.1362 13.9261 22.2811 13.1009 22.2413 11.6293H27.6703V11.1023C27.6703 8.34304 26.0197 7.2642 24.2896 7.2642C22.1618 7.2642 20.7598 8.88494 20.7598 11.2315C20.7598 13.603 22.1419 15.1541 24.394 15.1541ZM22.2463 10.5156C22.3059 9.43182 23.0914 8.49219 24.2995 8.49219C25.4529 8.49219 26.2086 9.3473 26.2136 10.5156H22.2463ZM30.8061 4.81818H29.3196V15H30.8061V4.81818ZM36.0971 15.1541C37.7626 15.1541 38.9409 14.3338 39.2789 13.0909L37.872 12.8374C37.6035 13.5582 36.9572 13.9261 36.112 13.9261C34.8393 13.9261 33.9842 13.1009 33.9444 11.6293H39.3734V11.1023C39.3734 8.34304 37.7228 7.2642 35.9927 7.2642C33.8649 7.2642 32.4629 8.88494 32.4629 11.2315C32.4629 13.603 33.845 15.1541 36.0971 15.1541ZM33.9494 10.5156C34.0091 9.43182 34.7946 8.49219 36.0027 8.49219C37.1561 8.49219 37.9118 9.3473 37.9167 10.5156H33.9494ZM44.5874 7.36364H43.0213V5.53409H41.5348V7.36364H40.4162V8.55682H41.5348V13.0661C41.5298 14.4531 42.5888 15.1243 43.7621 15.0994C44.2344 15.0945 44.5526 15.005 44.7266 14.9403L44.4581 13.7124C44.3587 13.7322 44.1747 13.777 43.9361 13.777C43.4538 13.777 43.0213 13.6179 43.0213 12.7578V8.55682H44.5874V7.36364ZM49.4409 15.1541C51.1064 15.1541 52.2846 14.3338 52.6227 13.0909L51.2157 12.8374C50.9473 13.5582 50.301 13.9261 49.4558 13.9261C48.1831 13.9261 47.3279 13.1009 47.2882 11.6293H52.7172V11.1023C52.7172 8.34304 51.0666 7.2642 49.3365 7.2642C47.2086 7.2642 45.8066 8.88494 45.8066 11.2315C45.8066 13.603 47.1887 15.1541 49.4409 15.1541ZM47.2931 10.5156C47.3528 9.43182 48.1383 8.49219 49.3464 8.49219C50.4998 8.49219 51.2555 9.3473 51.2605 10.5156H47.2931Z");
  path.setAttribute("fill", "black");
  customIcon.appendChild(rect);
  customIcon.appendChild(path);
  return customIcon;
}
function createDeleteSuccessIcon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  customIcon.setAttribute("viewBox", "0 0 12 12");
  customIcon.setAttribute("width", "12");
  customIcon.setAttribute("height", "12");
  customIcon.setAttribute("fill", "none");
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", "M6 0C2.688 0 0 2.688 0 6C0 9.312 2.688 12 6 12C9.312 12 12 9.312 12 6C12 2.688 9.312 0 6 0ZM6 10.8C3.354 10.8 1.2 8.646 1.2 6C1.2 3.354 3.354 1.2 6 1.2C8.646 1.2 10.8 3.354 10.8 6C10.8 8.646 8.646 10.8 6 10.8ZM8.754 3.348L4.8 7.302L3.246 5.754L2.4 6.6L4.8 9L9.6 4.2L8.754 3.348Z");
  path.setAttribute("fill", "white");
  customIcon.appendChild(path);
  return customIcon;
}
function createCloseIcon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  customIcon.setAttribute("viewBox", "0 0 12 12");
  customIcon.setAttribute("width", "12");
  customIcon.setAttribute("height", "12");
  customIcon.setAttribute("fill", "none");
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", "M10.773 2.28762L9.71231 1.22696L6 4.93927L2.28769 1.22696L1.22703 2.28762L4.93934 5.99993L1.22703 9.71224L2.28769 10.7729L6 7.06059L9.71231 10.7729L10.773 9.71224L7.06066 5.99993L10.773 2.28762Z");
  path.setAttribute("fill", "white");
  path.setAttribute("fill-rule", "evenodd");
  path.setAttribute("clip-rule", "evenodd");
  customIcon.appendChild(path);
  return customIcon;
}
function createErrorIcon() {
  const customIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  customIcon.setAttribute("viewBox", "0 0 12 10");
  customIcon.setAttribute("width", "12");
  customIcon.setAttribute("height", "10");
  customIcon.setAttribute("fill", "none");
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", "M0 10H11.5789L5.78947 0L0 10ZM6.31579 8.42105H5.26316V7.36842H6.31579V8.42105ZM6.31579 6.31579H5.26316V4.21053H6.31579V6.31579Z");
  path.setAttribute("fill", "#FF5050");
  customIcon.appendChild(path);
  return customIcon;
}

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyGeofenceControl/ui.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function AmplifyGeofenceControlUI(geofenceControl, geofenceControlContainer) {
  let _addGeofenceContainer;
  let _deleteGeofenceContainer;
  let _addGeofencebutton;
  let _checkboxAll;
  let _geofenceList;
  let _createContainer;
  let _geofenceTitle;
  let _checkBoxAllAndCreateContainer;
  let _checkBoxAllContainer;
  let _circleModeContainer;
  let _polygonModeContainer;
  let _deletePopdownContainer;
  let _errorDiv;
  let _geofenceCreateRadiusInput;
  function registerControlPosition(map, positionName) {
    if (map._controlPositions[positionName]) {
      return;
    }
    const positionContainer = document.createElement("div");
    positionContainer.className = `maplibregl-ctrl-${positionName}`;
    map._controlContainer.appendChild(positionContainer);
    map._controlPositions[positionName] = positionContainer;
  }
  function createGeofenceCreateContainer(isCircle) {
    const container = createElement("div", "geofence-ctrl-create-prompt-container", geofenceControlContainer);
    _createContainer = createElement("div", "geofence-ctrl-create-prompt", container);
    if (isCircle) {
      const buttonContainer = createElement("div", "geofence-ctrl-create-prompt-buttons", _createContainer);
      const circleModeButton = createElement("div", "geofence-ctrl-create-prompt-button-circle geofence-ctrl-create-prompt-button", buttonContainer);
      circleModeButton.addEventListener("click", () => {
        circleModeButton.classList.add("geofence-ctrl-create-prompt-selected");
        polygonModeButton.classList.remove("geofence-ctrl-create-prompt-selected");
        if (_polygonModeContainer) {
          removeElement(_polygonModeContainer);
          _polygonModeContainer = void 0;
        }
        if (!_circleModeContainer)
          createCircleModeCreateContainer(_createContainer);
        geofenceControl.changeMode("draw_circle");
      });
      circleModeButton.innerHTML = "Circle";
      const polygonModeButton = createElement("div", "geofence-ctrl-create-prompt-button-polygon geofence-ctrl-create-prompt-button", buttonContainer);
      polygonModeButton.addEventListener("click", () => {
        geofenceControl.changeMode("draw_polygon");
        polygonModeButton.classList.add("geofence-ctrl-create-prompt-selected");
        circleModeButton.classList.remove("geofence-ctrl-create-prompt-selected");
        if (_circleModeContainer) {
          removeElement(_circleModeContainer);
          _circleModeContainer = void 0;
        }
        if (!_polygonModeContainer)
          createPolygonModeCreateContainer(_createContainer);
      });
      polygonModeButton.innerHTML = "Custom";
      circleModeButton.classList.add("geofence-ctrl-create-prompt-selected");
      createCircleModeCreateContainer(_createContainer);
    } else {
      createPolygonModeCreateContainer(_createContainer);
    }
  }
  function createCircleModeCreateContainer(container) {
    _circleModeContainer = createElement("div", "geofence-ctrl-create-circle-mode-container", container);
    const radiusTitle = createElement("div", "geofence-ctrl-create-circle-mode-title", _circleModeContainer);
    radiusTitle.innerHTML = "Radius";
    _geofenceCreateRadiusInput = createElement("input", "geofence-ctrl-create-circle-mode-input", _circleModeContainer);
    _geofenceCreateRadiusInput.addEventListener("keydown", (0, import_debounce.debounce)(geofenceControl.updateInputRadius, 200));
  }
  function createPolygonModeCreateContainer(container) {
    _polygonModeContainer = createElement("div", "geofence-ctrl-create-polygon-mode-container", container);
    const moreInfoContainer = createElement("div", "geofence-ctrl-create-polygon-mode-info-container", _polygonModeContainer);
    const moreInfoIcon = createElement("div", "geofence-ctrl-create-polygon-mode-icon", moreInfoContainer);
    const letterI = createElement("div", "geofence-ctrl-create-polygon-mode-info-icon", moreInfoIcon);
    letterI.innerHTML = "i";
    const moreInfo = createElement("div", "geofence-ctrl-create-polygon-mode-title", moreInfoContainer);
    moreInfo.innerHTML = "How it works?";
    const resetButton = createElement("div", "geofence-ctrl-create-polygon-mode-reset-button geofence-ctrl-button", _polygonModeContainer);
    resetButton.innerHTML = "Reset";
    resetButton.addEventListener("click", () => {
      geofenceControl.resetGeofence();
    });
    const popup = createPolygonModeInfoPopup(moreInfoIcon);
    moreInfoContainer.addEventListener("click", () => {
      popup.classList.toggle("show");
    });
  }
  function createPolygonModeInfoPopup(container) {
    const popupContainer = createElement("div", "geofence-ctrl-create-polygon-mode-popup-container", container);
    const popup = createElement("div", "geofence-ctrl-create-polygon-mode-popup", popupContainer);
    createPopupStep(popup, "Move dots to desired position", createPopupStep1Icon());
    createPopupStep(popup, "Click on a border to create a dot", createPopupStep2Icon());
    createPopupStep(popup, "Click into shape to move", createPopupStep3Icon());
    createPopupStep(popup, "Press delete to remove a dot", createPopupStep4Icon());
    return popup;
  }
  function createPopupStep(container, text, image) {
    const popupStep = createElement("div", "geofence-ctrl-create-polygon-mode-popup-step", container);
    const popupStepImage = createElement("div", "geofence-ctrl-create-polygon-mode-popup-step-image", popupStep);
    popupStepImage.appendChild(image);
    const popupStepText = createElement("div", "geofence-ctrl-create-polygon-mode-popup-step-text", popupStep);
    popupStepText.innerHTML = text;
  }
  function removeGeofenceCreateContainer() {
    removeElement(_createContainer);
    _createContainer = void 0;
    _circleModeContainer = void 0;
    _polygonModeContainer = void 0;
  }
  function createGeofenceListContainer() {
    const geofenceListContainer = createElement("div", "geofence-ctrl-list-container", geofenceControlContainer);
    createGeofenceListHeader(geofenceListContainer);
    _geofenceList = createElement("div", "geofence-ctrl-list", geofenceListContainer);
    _geofenceList.addEventListener("scroll", () => {
      const { scrollHeight, scrollTop, clientHeight } = _geofenceList;
      if (scrollTop + clientHeight >= scrollHeight - 20) {
        geofenceControl.loadMoreGeofences();
      }
    });
  }
  function createGeofenceListHeader(geofenceListContainer) {
    const header = createElement("div", "geofence-ctrl-list-header", geofenceListContainer);
    _geofenceTitle = createElement("div", "geofence-ctrl-list-header-title", header);
    _geofenceTitle.innerHTML = "Geofences (0)";
    _checkBoxAllAndCreateContainer = createElement("div", "geofence-ctrl-list-header-checkbox-create-container", header);
    createCheckboxAllContainer(_checkBoxAllAndCreateContainer);
  }
  function createCheckboxAllContainer(geofenceListContainer) {
    _checkBoxAllContainer = createElement("div", "geofence-ctrl-list-checkbox-all-container", geofenceListContainer);
    _checkboxAll = createElement("input", "geofence-ctrl-list-checkbox-all", _checkBoxAllContainer);
    _checkboxAll.type = "checkbox";
    _checkboxAll.addEventListener("click", function() {
      if (_checkboxAll.checked) {
        geofenceControl.displayAllGeofences();
        checkboxAllText.innerHTML = "Deselect All";
      } else {
        geofenceControl.hideAllGeofences();
        checkboxAllText.innerHTML = "Select All";
      }
    });
    const checkboxAllText = createElement("div", "geofence-ctrl-list-checkbox-all-title", _checkBoxAllContainer);
    checkboxAllText.innerHTML = "Select all";
    _addGeofencebutton = createElement("div", "geofence-ctrl-list-header-add-button", _checkBoxAllContainer);
    _addGeofencebutton.innerHTML = "+ Add";
    _addGeofencebutton.addEventListener("click", () => {
      createAddGeofenceContainer();
    });
  }
  function renderListItem(geofence) {
    const container = createElement("li", "geofence-ctrl-list-item-container", _geofenceList);
    container.id = `list-item-${geofence.geofenceId}`;
    const listItem = createElement("li", "geofence-ctrl-list-item", container);
    const leftContainer = createElement("div", "geofence-ctrl-list-item-left-container", listItem);
    const checkbox = createElement("input", "geofence-ctrl-list-item-checkbox", leftContainer);
    checkbox.id = `list-item-checkbox-${geofence.geofenceId}`;
    checkbox.type = "checkbox";
    checkbox.addEventListener("click", function() {
      if (checkbox.checked) {
        geofenceControl.displayGeofence(geofence.geofenceId);
        geofenceControl.fitGeofence(geofence.geofenceId);
      } else {
        geofenceControl.hideGeofence(geofence.geofenceId);
      }
    });
    const rightContainer = createElement("div", "geofence-ctrl-list-item-right-container", listItem);
    const geofenceTitleContainer = createElement("div", "geofence-ctrl-list-item-title-container", rightContainer);
    geofenceTitleContainer.addEventListener("mouseover", function() {
      geofenceControl.displayHighlightedGeofence(geofence.geofenceId);
    });
    geofenceTitleContainer.addEventListener("mouseout", function() {
      geofenceControl.hideHighlightedGeofence();
    });
    const geofenceTitle = createElement("div", "geofence-ctrl-list-item-title", geofenceTitleContainer);
    geofenceTitle.innerHTML = geofence.geofenceId;
    const editButton = createElement("div", "geofence-ctrl-edit-button", geofenceTitleContainer);
    editButton.addEventListener("click", function() {
      geofenceControl.editGeofence(geofence.geofenceId);
      createEditControls(listItem, rightContainer, leftContainer, geofence.geofenceId);
      listItem.classList.remove("geofence-ctrl-list-item");
      listItem.classList.add("geofence-ctrl-list-selected-item");
    });
    editButton.appendChild(createEditIcon());
  }
  function createEditControls(item, rightContainer, leftContainer, id) {
    const editContainer = createElement("div", "geofence-ctrl-list-item-controls", rightContainer);
    const deleteButton = renderDeleteButton(leftContainer, id);
    const removeEditContainer = () => {
      item.classList.remove("geofence-ctrl-list-selected-item");
      item.classList.add("geofence-ctrl-list-item");
      removeElement(editContainer);
      removeElement(deleteButton);
    };
    const cancelButton = createElement("div", "geofence-ctrl-cancel-button", editContainer);
    cancelButton.classList.add("geofence-ctrl-button");
    cancelButton.innerHTML = "Cancel";
    cancelButton.addEventListener("click", () => {
      geofenceControl.setEditingModeEnabled(false);
      removeEditContainer();
    });
    const saveGeofenceButton = createElement("div", "geofence-ctrl-save-button geofence-ctrl-button", editContainer);
    saveGeofenceButton.addEventListener("click", () => __awaiter3(this, void 0, void 0, function* () {
      yield geofenceControl.saveGeofence();
      removeEditContainer();
    }));
    saveGeofenceButton.title = "Save";
    saveGeofenceButton.innerHTML = "Save";
  }
  function removeAddGeofenceContainer() {
    removeElement(_addGeofenceContainer);
    clearAddGeofenceError();
    showCheckboxAllContainer();
  }
  function clearAddGeofenceError() {
    if (_errorDiv) {
      removeElement(_errorDiv);
      _errorDiv = void 0;
    }
  }
  function createAddGeofenceContainer() {
    hideCheckboxAllContainer();
    _addGeofenceContainer = createElement("div", "geofence-ctrl-add-geofence-container", _checkBoxAllAndCreateContainer);
    const addGeofencePrompt = createElement("div", "geofence-ctrl-add-geofence", _addGeofenceContainer);
    const nameInput = createElement("input", "geofence-ctrl-add-geofence-input", addGeofencePrompt);
    nameInput.placeholder = "Enter name";
    const buttonContainer = createElement("div", "geofence-ctrl-add-geofence-buttons", addGeofencePrompt);
    const cancelButton = createElement("div", "geofence-ctrl-add-geofence-cancel-button geofence-ctrl-button ", buttonContainer);
    cancelButton.innerHTML = "Cancel";
    cancelButton.addEventListener("click", () => {
      removeAddGeofenceContainer();
      geofenceControl.setEditingModeEnabled(false);
    });
    const saveButton = createElement("div", "geofence-ctrl-button geofence-ctrl-save-button", buttonContainer);
    saveButton.innerHTML = "Save";
    saveButton.addEventListener("click", function() {
      return __awaiter3(this, void 0, void 0, function* () {
        clearAddGeofenceError();
        const output = yield geofenceControl.createGeofence(escape(nameInput.value));
        if (output)
          removeAddGeofenceContainer();
      });
    });
    geofenceControl.addEditableGeofence();
  }
  function createAddGeofencePromptError(error) {
    if (_errorDiv) {
      return;
    }
    _errorDiv = createElement("div", "geofence-ctrl-add-geofence-error", _addGeofenceContainer);
    const errorIconContainer = createElement("div", "geofence-ctrl-add-geofence-error-icon", _errorDiv);
    errorIconContainer.appendChild(createErrorIcon());
    const errorText = createElement("div", "geofence-ctrl-add-geofence-error-text", _errorDiv);
    errorText.innerHTML = error;
  }
  function renderDeleteButton(container, id) {
    const deleteButton = createElement("div", "geofence-ctrl-delete-button", container);
    deleteButton.classList.add("geofence-ctrl-button");
    deleteButton.addEventListener("click", function() {
      createConfirmDeleteContainer(id);
    });
    deleteButton.appendChild(createTrashIcon());
    return deleteButton;
  }
  function createConfirmDeleteContainer(geofenceId) {
    _deleteGeofenceContainer = createElement("div", "geofence-ctrl-delete-prompt-container", geofenceControlContainer);
    const deleteGeofencePrompt = createElement("div", "geofence-ctrl-delete-prompt", _deleteGeofenceContainer);
    const title = createElement("div", "geofence-ctrl-delete-geofence-title", deleteGeofencePrompt);
    title.innerHTML = `Are you sure you want to delete <strong>${geofenceId}</strong>?`;
    createDeleteButtonsContainer(deleteGeofencePrompt, geofenceId);
  }
  function createDeleteButtonsContainer(container, geofenceId) {
    const deleteButtonsContainer = createElement("div", "geofence-ctrl-delete-geofence-buttons", container);
    const cancelButton = createElement("div", "geofence-ctrl-delete-geofence-cancel-button", deleteButtonsContainer);
    cancelButton.innerHTML = "Cancel";
    cancelButton.addEventListener("click", () => {
      removeElement(_deleteGeofenceContainer);
    });
    const confirmDeleteButton = createElement("div", "geofence-ctrl-delete-geofence-confirm-button", deleteButtonsContainer);
    confirmDeleteButton.innerHTML = "Delete";
    confirmDeleteButton.addEventListener("click", function() {
      return __awaiter3(this, void 0, void 0, function* () {
        const id = yield geofenceControl.deleteGeofence(geofenceId);
        if (id) {
          createDeleteResultContainer(true);
          removeElement(_deleteGeofenceContainer);
          geofenceControl.setEditingModeEnabled(false);
        }
      });
    });
  }
  function createDeleteResultContainer(success) {
    _deletePopdownContainer = createElement("div", "geofence-ctrl-delete-popdown-container", geofenceControlContainer);
    const deletePopdown = createElement("div", "geofence-ctrl-delete-popdown", _deletePopdownContainer);
    const deletePopdownCloseButton = createElement("div", "geofence-ctrl-delete-popdown-close-button", _deletePopdownContainer);
    deletePopdownCloseButton.appendChild(createCloseIcon());
    deletePopdownCloseButton.addEventListener("click", () => {
      removeElement(_deletePopdownContainer);
    });
    const deleteSuccessIcon = createElement("div", "geofence-ctrl-delete-popdown-icon", deletePopdown);
    deleteSuccessIcon.appendChild(createDeleteSuccessIcon());
    const deletePopdownText = createElement("div", "geofence-ctrl-delete-popdown-text", deletePopdown);
    deletePopdownText.innerHTML = success ? "Geofence was deleted successfully" : "Geofence failed to delete";
  }
  function updateCheckbox(geofenceId, checked) {
    const checkbox = document.getElementById(`list-item-checkbox-${geofenceId}`);
    if (checkbox)
      checkbox.checked = checked;
  }
  function removeGeofenceListItem(geofenceId) {
    const listItem = document.getElementById(`list-item-${geofenceId}`);
    removeElement(listItem);
  }
  function setGeofenceListEnabled(enabled) {
    _checkboxAll.disabled = !enabled;
    enabled ? _addGeofencebutton.classList.remove("geofence-ctrl-noHover") : _addGeofencebutton.classList.add("geofence-ctrl-noHover");
    const inputs = document.getElementsByClassName("geofence-ctrl-list-item-checkbox");
    for (let i = 0; i < inputs.length; i++) {
      inputs.item(i).disabled = !enabled;
    }
    const items = document.getElementsByClassName("geofence-ctrl-list-item-container");
    for (let i = 0; i < items.length; i++) {
      enabled ? items.item(i).classList.remove("geofence-ctrl-noHover") : items.item(i).classList.add("geofence-ctrl-noHover");
    }
  }
  function getCheckboxAllValue() {
    return _checkboxAll.checked;
  }
  function updateGeofenceCount(count) {
    _geofenceTitle.innerHTML = `Geofences (${count})`;
  }
  function updateGeofenceRadius(radius) {
    if (_geofenceCreateRadiusInput)
      _geofenceCreateRadiusInput.value = `${radius}`;
  }
  function hideCheckboxAllContainer() {
    _checkBoxAllContainer.style.display = "none";
  }
  function showCheckboxAllContainer() {
    _checkBoxAllContainer.style.display = "flex";
  }
  return {
    registerControlPosition,
    createElement,
    removeElement,
    createGeofenceCreateContainer,
    createGeofenceListContainer,
    removeAddGeofenceContainer,
    createAddGeofencePromptError,
    renderListItem,
    updateCheckbox,
    removeGeofenceListItem,
    setGeofenceListEnabled,
    getCheckboxAllValue,
    removeGeofenceCreateContainer,
    updateGeofenceCount,
    updateGeofenceRadius
  };
}

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyGeofenceControl/AmplifyMapDraw.js
var import_mapbox_gl_draw = __toESM(require_mapbox_gl_draw());
var import_maplibre_gl_draw_circle = __toESM(require_maplibre_gl_draw_circle());
var AmplifyMapDraw = class {
  constructor(map, ui) {
    this._mapBoxDraw = new import_mapbox_gl_draw.default({
      displayControlsDefault: false,
      defaultMode: "simple_select",
      userProperties: true,
      controls: {
        trash: true
      },
      modes: Object.assign(Object.assign({}, import_mapbox_gl_draw.default.modes), { draw_circle: import_maplibre_gl_draw_circle.CircleMode, direct_select: import_maplibre_gl_draw_circle.DirectMode, simple_select: import_maplibre_gl_draw_circle.SimpleSelectMode }),
      styles: [
        {
          id: "gl-draw-polygon-fill",
          type: "fill",
          filter: ["all", ["==", "$type", "Polygon"], ["!=", "mode", "static"]],
          paint: {
            "fill-color": GEOFENCE_COLOR,
            "fill-outline-color": GEOFENCE_COLOR,
            "fill-opacity": 0.3
          }
        },
        {
          id: "gl-draw-polygon-midpoint",
          type: "circle",
          filter: ["all", ["==", "$type", "Point"], ["==", "meta", "midpoint"]],
          paint: {
            "circle-radius": 5,
            "circle-color": GEOFENCE_VERTEX_COLOR
          }
        },
        {
          id: "gl-draw-polygon-stroke-active",
          type: "line",
          filter: ["all", ["==", "$type", "Polygon"], ["!=", "mode", "static"]],
          layout: {
            "line-cap": "round",
            "line-join": "round"
          },
          paint: {
            "line-color": GEOFENCE_BORDER_COLOR,
            "line-width": 4
          }
        },
        {
          id: "gl-draw-polygon-and-line-vertex-active",
          type: "circle",
          filter: [
            "all",
            ["==", "meta", "vertex"],
            ["==", "$type", "Point"],
            ["!=", "mode", "static"]
          ],
          paint: {
            "circle-radius": 8,
            "circle-color": GEOFENCE_VERTEX_COLOR,
            "circle-stroke-color": GEOFENCE_BORDER_COLOR,
            "circle-stroke-width": 1
          }
        }
      ]
    });
    this._map = map;
    this._ui = ui;
    this.enable = this.enable.bind(this);
    this.disable = this.disable.bind(this);
    this.drawPolygonGeofence = this.drawPolygonGeofence.bind(this);
  }
  get(id) {
    return this._mapBoxDraw.get(id);
  }
  add(data) {
    const isCircle = data.properties.isCircle;
    this.enable(isCircle);
    this._mapBoxDraw.add(data);
    this._mapBoxDraw.changeMode("direct_select", {
      featureId: data.id
    });
  }
  delete(id) {
    this._mapBoxDraw.delete(id);
  }
  disable() {
    if (this._map.hasControl(this._mapBoxDraw)) {
      this._map.removeControl(this._mapBoxDraw);
    }
    this._ui.removeGeofenceCreateContainer();
  }
  enable(isCircle) {
    if (this._map.hasControl(this._mapBoxDraw)) {
      return;
    }
    this._map.addControl(this._mapBoxDraw, "bottom-right");
    this._ui.createGeofenceCreateContainer(isCircle);
  }
  drawPolygonGeofence(id) {
    const mapBounds = this._map.getBounds();
    const feature2 = getPolygonFeatureFromBounds(id, mapBounds);
    this.add(feature2);
  }
  drawCircularGeofence(id, radius) {
    const mapBounds = this._map.getBounds();
    const circleFeature = getCircleFeatureFromCoords(id, this._map.getCenter().toArray(), { bounds: mapBounds, radius });
    this.add(circleFeature);
    this._ui.updateGeofenceRadius(radius || circleFeature.properties.radius.toFixed(2));
  }
};

// node_modules/maplibre-gl-js-amplify/lib/esm/AmplifyGeofenceControl/index.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FIT_BOUNDS_PADDING = { left: 240 };
var AmplifyGeofenceControl = class {
  constructor(options) {
    this._geofenceCollectionId = options === null || options === void 0 ? void 0 : options.geofenceCollectionId;
    this._loadedGeofences = {};
    this._displayedGeofences = [];
    this.changeMode = this.changeMode.bind(this);
    this.loadInitialGeofences = this.loadInitialGeofences.bind(this);
    this.loadMoreGeofences = this.loadMoreGeofences.bind(this);
    this._loadGeofence = this._loadGeofence.bind(this);
    this.updateInputRadius = this.updateInputRadius.bind(this);
    this.saveGeofence = this.saveGeofence.bind(this);
    this.editGeofence = this.editGeofence.bind(this);
    this.deleteGeofence = this.deleteGeofence.bind(this);
    this.displayAllGeofences = this.displayAllGeofences.bind(this);
    this.hideAllGeofences = this.hideAllGeofences.bind(this);
    this.addEditableGeofence = this.addEditableGeofence.bind(this);
    this.setEditingModeEnabled = this.setEditingModeEnabled.bind(this);
    this.displayHighlightedGeofence = this.displayHighlightedGeofence.bind(this);
    this.hideHighlightedGeofence = this.hideHighlightedGeofence.bind(this);
    this.displayGeofence = this.displayGeofence.bind(this);
    this.hideGeofence = this.hideGeofence.bind(this);
    this.fitGeofence = this.fitGeofence.bind(this);
    this.fitAllGeofences = this.fitAllGeofences.bind(this);
  }
  getDefaultPosition() {
    return "full-screen";
  }
  onRemove() {
    this._ui.removeElement(this._container);
  }
  reorderMapLibreClassNames() {
    const mapCanvas = document.getElementsByClassName("maplibregl-canvas").item(0);
    if (mapCanvas) {
      mapCanvas.className = "mapboxgl-canvas maplibregl-canvas";
    }
  }
  onAdd(map) {
    this._map = map;
    this.reorderMapLibreClassNames();
    this._container = createElement("div", "geofence-ctrl maplibregl-ctrl");
    this._ui = AmplifyGeofenceControlUI(this, this._container);
    this._amplifyDraw = new AmplifyMapDraw(map, this._ui);
    this._ui.registerControlPosition(map, "full-screen");
    this._ui.createGeofenceListContainer();
    this._map.once("load", function() {
      if (this._map.getSource("displayedGeofences")) {
        return;
      }
      this._drawGeofencesOutput = drawGeofences("displayedGeofences", [], this._map, {
        fillColor: GEOFENCE_COLOR,
        borderColor: GEOFENCE_BORDER_COLOR,
        borderOpacity: 1
      });
      this._highlightedGeofenceOutput = drawGeofences("highlightedGeofence", [], this._map, {
        fillColor: GEOFENCE_COLOR,
        borderColor: GEOFENCE_BORDER_COLOR,
        borderOpacity: 1,
        borderWidth: 6
      });
      this.loadInitialGeofences();
      map.addControl(new import_maplibre_gl4.default.NavigationControl({ showCompass: false }), "bottom-right");
    }.bind(this));
    this._map.on("draw.update", () => {
      const coordinates = this._amplifyDraw._mapBoxDraw.getAll().features[0].geometry.coordinates[0];
      const radius = getDistanceBetweenCoordinates(coordinates[0], coordinates[Math.floor(coordinates.length / 2)]) / 2;
      this._ui.updateGeofenceRadius(radius.toFixed(2));
    });
    return this._container;
  }
  createGeofence(geofenceId) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!geofenceId || geofenceId.length === 0) {
        this._ui.createAddGeofencePromptError("Geofence ID is empty.");
        return;
      }
      if (!isValidGeofenceId(geofenceId)) {
        this._ui.createAddGeofencePromptError("Geofence ID contains special characters.");
        return;
      }
      if (isExistingGeofenceId(geofenceId, this._loadedGeofences)) {
        this._ui.createAddGeofencePromptError("Geofence ID already exists.");
        return;
      }
      return this.saveGeofence(geofenceId);
    });
  }
  saveGeofence(geofenceId) {
    return __awaiter4(this, void 0, void 0, function* () {
      const feature2 = this._amplifyDraw.get(this._editingGeofenceId);
      const idToSave = geofenceId || this._editingGeofenceId;
      const response = yield Geo.saveGeofences({
        geofenceId: idToSave,
        geometry: { polygon: feature2.geometry["coordinates"] }
      });
      if (response.errors[0]) {
        const err = response.errors[0];
        throw new Error(`There was an error saving geofence with id ${idToSave}: ${err.error.code} - ${err.error.message}`);
      }
      const success = response.successes[0];
      const savedGeofence = {
        geofenceId: success.geofenceId,
        geometry: { polygon: feature2.geometry["coordinates"] }
      };
      this._loadGeofence(savedGeofence);
      this.displayGeofence(savedGeofence.geofenceId);
      this.setEditingModeEnabled(false);
      return savedGeofence.geofenceId;
    });
  }
  loadInitialGeofences() {
    return __awaiter4(this, void 0, void 0, function* () {
      try {
        const { entries, nextToken } = yield Geo.listGeofences();
        this._listGeofencesNextToken = nextToken;
        const loadGeofence = this._loadGeofence;
        entries.forEach((geofence) => loadGeofence(geofence));
        this._ui.updateGeofenceCount(Object.keys(this._loadedGeofences).length);
      } catch (e2) {
        throw new Error(`Error calling listGeofences: ${e2}`);
      }
    });
  }
  loadMoreGeofences() {
    return __awaiter4(this, void 0, void 0, function* () {
      if (this._listGeofencesNextToken) {
        try {
          const { entries, nextToken } = yield Geo.listGeofences({
            nextToken: this._listGeofencesNextToken
          });
          this._listGeofencesNextToken = nextToken;
          const loadGeofence = this._loadGeofence;
          entries.forEach((geofence) => loadGeofence(geofence));
          this._ui.updateGeofenceCount(Object.keys(this._loadedGeofences).length);
        } catch (e2) {
          throw new Error(`Error calling listGeofences: ${e2}`);
        }
      }
    });
  }
  editGeofence(geofenceId) {
    this.setEditingModeEnabled(true);
    const geofence = this._loadedGeofences[geofenceId];
    if (!geofence) {
      throw new Error(`Geofence with id ${geofenceId} does not exist`);
    }
    const feature2 = getGeofenceFeatureFromPolygon(geofence.geometry.polygon);
    const data = Object.assign({ id: geofence.geofenceId }, feature2);
    this._amplifyDraw.add(data);
    this._editingGeofenceId = geofence.geofenceId;
  }
  deleteGeofence(geofenceId) {
    return __awaiter4(this, void 0, void 0, function* () {
      const response = yield Geo.deleteGeofences(geofenceId);
      if (response.errors[0]) {
        const err = response.errors[0].error;
        throw new Error(`There was an error deleting geofence with id ${geofenceId}: ${err.code} - ${err.message}`);
      }
      this._ui.removeGeofenceListItem(geofenceId);
      delete this._loadedGeofences[geofenceId];
      this._ui.updateGeofenceCount(Object.keys(this._loadedGeofences).length);
      this._displayedGeofences = this._displayedGeofences.filter((geofence) => geofence.geofenceId !== geofenceId);
      this._updateDisplayedGeofences();
      return geofenceId;
    });
  }
  deleteSelectedGeofences() {
    const idsToDelete = this._displayedGeofences.map((fence) => fence.geofenceId);
    idsToDelete.forEach((id) => {
      this._ui.removeGeofenceListItem(id);
      delete this._loadedGeofences[id];
    });
    this._displayedGeofences = [];
    this._updateDisplayedGeofences();
  }
  _loadGeofence(geofence) {
    if (this._loadedGeofences[geofence.geofenceId]) {
      this._displayedGeofences = this._displayedGeofences.filter((fence) => fence.geofenceId !== geofence.geofenceId);
    } else {
      this._ui.renderListItem(geofence);
    }
    this._loadedGeofences[geofence.geofenceId] = geofence;
    this._ui.updateGeofenceCount(Object.keys(this._loadedGeofences).length);
  }
  displayGeofence(geofenceId) {
    this._displayedGeofences.push(this._loadedGeofences[geofenceId]);
    this._updateDisplayedGeofences();
    this._ui.updateCheckbox(geofenceId, true);
    this.fitAllGeofences();
  }
  displayAllGeofences() {
    this._displayedGeofences.push(...Object.values(this._loadedGeofences));
    this._updateDisplayedGeofences();
    const checkboxes = document.getElementsByClassName("geofence-ctrl-list-item-checkbox");
    Array.from(checkboxes).forEach((checkbox) => checkbox.checked = this._ui.getCheckboxAllValue());
    this.fitAllGeofences();
  }
  fitGeofence(geofenceId) {
    const mapBounds = this._map.getBounds();
    const geofence = this._loadedGeofences[geofenceId];
    geofence.geometry.polygon[0].forEach((coord) => {
      mapBounds.extend(coord);
    });
    this._map.fitBounds(mapBounds, { padding: FIT_BOUNDS_PADDING });
  }
  fitAllGeofences() {
    let shouldFitBounds = false;
    const mapBounds = this._map.getBounds();
    this._displayedGeofences.forEach((geofence) => {
      geofence.geometry.polygon[0].forEach((coord) => {
        if (!mapBounds.contains(coord)) {
          mapBounds.extend(coord);
          shouldFitBounds = true;
        }
      });
    });
    if (shouldFitBounds)
      this._map.fitBounds(mapBounds, { padding: FIT_BOUNDS_PADDING });
  }
  hideGeofence(geofenceId) {
    this._displayedGeofences = this._displayedGeofences.filter((geofence) => geofence.geofenceId !== geofenceId);
    this._updateDisplayedGeofences();
    this._ui.updateCheckbox(geofenceId, false);
  }
  hideAllGeofences() {
    this._displayedGeofences = [];
    this._updateDisplayedGeofences();
    const checkboxes = document.getElementsByClassName("geofence-ctrl-list-item-checkbox");
    Array.from(checkboxes).forEach((checkbox) => checkbox.checked = this._ui.getCheckboxAllValue());
  }
  _updateDisplayedGeofences() {
    const feature2 = getGeofenceFeatureArray(this._displayedGeofences);
    this._drawGeofencesOutput.setData(feature2);
  }
  displayHighlightedGeofence(geofenceId) {
    const geofence = this._loadedGeofences[geofenceId];
    if (!geofence) {
      console.warn(`Geofence with id ${geofenceId} does not exist`);
      return;
    }
    const feature2 = getGeofenceFeatureFromPolygon(geofence.geometry.polygon);
    this._highlightedGeofenceOutput.setData(feature2);
    this._highlightedGeofenceOutput.show();
  }
  hideHighlightedGeofence() {
    this._highlightedGeofenceOutput.hide();
  }
  changeMode(mode) {
    this._amplifyDraw.delete(this._editingGeofenceId);
    if (mode === "draw_circle") {
      this._amplifyDraw.drawCircularGeofence(this._editingGeofenceId);
    } else {
      this._amplifyDraw.drawPolygonGeofence(this._editingGeofenceId);
    }
  }
  resetGeofence() {
    this._amplifyDraw.delete(this._editingGeofenceId);
    if (isExistingGeofenceId(this._editingGeofenceId, this._loadedGeofences)) {
      this.editGeofence(this._editingGeofenceId);
    } else {
      this._amplifyDraw.drawPolygonGeofence(this._editingGeofenceId);
    }
  }
  setEditingModeEnabled(enabled) {
    enabled ? this._amplifyDraw.enable() : this._amplifyDraw.disable();
    enabled ? this._drawGeofencesOutput.hide() : this._drawGeofencesOutput.show();
    this._ui.setGeofenceListEnabled(!enabled);
  }
  updateInputRadius(event) {
    const radiusString = event.target.value;
    const radius = parseInt(radiusString);
    if (isNaN(radius)) {
      return;
    }
    this._amplifyDraw.drawCircularGeofence(this._editingGeofenceId, radius);
  }
  addEditableGeofence() {
    this._editingGeofenceId = "tempGeofence";
    this._amplifyDraw.drawCircularGeofence("tempGeofence");
    this.setEditingModeEnabled(true);
  }
};
export {
  AmplifyGeocoderAPI,
  AmplifyGeofenceControl,
  AmplifyMapLibreRequest,
  createAmplifyGeocoder,
  createDefaultIcon,
  createMap,
  drawGeofences,
  drawPoints
};
//# sourceMappingURL=maplibre-gl-js-amplify.js.map
